<details><summary>c</summary>

---

##  **ベースライン: `adi.c`**

ADIスキームの逐次実装。特徴：

* **時間ステップごとに2段階の掃き操作（列→行）**
* 各方向で **前進スイープ + 後退スイープ（Tridiagonalソルバー）**
* OpenMP なし（逐次実行）
* PolyBench 用の `#pragma scop` スコープに包まれている

---

##  `opt_1.c` の違い

*  **OpenMP 並列化導入**

  * `#pragma omp parallel` と `#pragma omp for` を各スイープの外側ループに追加。
*  `schedule(static)` 指定なし（スケジューリング方式は実装依存）
*  **p, q, v, u の計算手順は `adi.c` と完全一致**
*  ベクトル化や計算式の簡略化なし

>  `opt_1` = 並列化による計算分担強化。実装構造はそのまま。

---

##  `opt_2.c` の違い

*  `opt_1` と同じく OpenMP 導入
*  **各ループに `schedule(static)` を明示的に指定**
*  一部変数（例：`pijm1`）の**定義タイミング変更でスコープ最適化**
*  全体構造・ロジック・数値計算は `opt_1` と一致

>  `opt_2` = `opt_1` + **スケジューリング安定化** + スコープ整理 → より確実な性能再現性狙い

---

##  `opt_3.c` の違い

*  `opt_2` の構造をそのまま継承
*  明確に**p, q, v, u 各ステージでのローカル変数の初期化を強化**

  * `v0i` や `p[i][0] = 0` など明示的代入の最適位置に再配置
*  演算式での**スカラー定数の事前宣言強化**
*  **全OpenMPループに `schedule(static)` が残る**

>  `opt_3` = `opt_2` + ローカル変数と定数の管理の明示化による**データ競合のリスク低減** & **最小限のメモリアクセス**

---

##  比較まとめ表

| 観点          | `adi.c` | `opt_1.c`   | `opt_2.c`                    | `opt_3.c`                |
| ----------- | ------- | ----------- | ---------------------------- | ------------------------ |
| OpenMP 並列化  | ❌       | ✅ `omp for` | ✅ `omp for schedule(static)` | ✅ 同上                     |
| スケジューリング最適化 | ❌       | ❌           | ✅                            | ✅                        |
| スカラー定数の整理   | ❌       | 部分的         | 一部                           | ✅ `v0i`, `pijm1` の配置を最適化 |
| ロジック構造      | 基本形     | 同じ          | 同じ                           | 同じ（最適化あり）                |
| メモリアクセスの最適化 | ❌       | ❌           | ❌                            | ✅ 変数の初期化順調整              |

---

##  結論

* **`opt_1`**：逐次構造にOpenMP導入だけ → **導入の第一段階**
* **`opt_2`**：並列スケジューリングまで制御 → **安定したパフォーマンス狙い**
* **`opt_3`**：局所変数制御と命令整理まで含めた最適化 → **スレッド安全性 + 効率性**
</details>

<details><summary>ll</summary>

---

##  **ベースライン（base.ll）特徴**

*  単一スレッド構成、OpenMPの痕跡なし。
* ループ構造は単純な`for`命令展開。
* `!llvm.loop.*`メタデータの付与なし（ベクトル化、アンローリング不可）。
* 計算式はそのままコンパイルされており、スカラー最適化なども未適用。

---

##  `opt_1.ll` の違い

*  `__kmpc_fork_call`, `__kmpc_for_static_init` など**OpenMP ランタイム呼び出しあり**
*  `@.omp_outlined.*` 関数が生成 → 各forループが分離・アウトライン化
*  ベクトル命令やループ最適化 (`!llvm.loop.*`) はなし
*  スレッド並列処理の実行は可能（ただし**スケジューリング未指定**）

>  `opt_1.ll` = **並列処理化のみの導入。最適化パスは浅い。**

---

##  `opt_2.ll` の違い

*  `opt_1`と同様にOpenMP展開あり（`__kmpc_*`、`omp_outlined`）
*  **ループに `schedule(static)` 相当のパラメータが明示的に含まれている**

  * LLVMレベルでは `__kmpc_for_static_init_4` の第6引数で確認可
*  スカラー計算定数（例：`a`,`b`,`c`など）がループ外で事前に `alloca` + `store`される最適化あり
*  依然として `!llvm.loop.vectorize` はなし（ベクトル化未対応）

>  `opt_2.ll` = 並列スケジューリング制御まで導入した中間最適化形態。

---

##  `opt_3.ll` の違い

*  `opt_2`構成をすべて包含
*  一部ループに **ベクトル化・アンローリング関連メタデータ** の追加：

  * `!llvm.loop.vectorize.enable = true`
  * `!llvm.loop.unroll.enable = true`
*  ローカル変数の管理がより精緻に（メモリアクセス削減の形跡あり）

  * `load` の繰り返しが減り、`phi`ノード経由で再利用されるケース増加

>  `opt_3.ll` = OpenMP 並列化 + スケジューリング + ベクトル化とループアンローリングが合体した**最適形**

---

##  比較まとめ表（IRレベル）

| 最適化項目                    | base.ll | opt\_1.ll | opt\_2.ll | opt\_3.ll |
| ------------------------ | ------- | --------- | --------- | --------- |
| OpenMP (`__kmpc_*`) 呼び出し | ❌       | ✅         | ✅         | ✅         |
| Outlined 関数              | ❌       | ✅         | ✅         | ✅         |
| スケジューリング制御               | ❌       | ❌         | ✅         | ✅         |
| 定数事前計算 (`alloca`)        | ❌       | ❌         | ✅         | ✅         |
| ループベクトル化メタ               | ❌       | ❌         | ❌         | ✅         |
| ループアンローリング               | ❌       | ❌         | ❌         | ✅         |

---

##  結論

* **`opt_1.ll`**：並列化の基礎導入、マルチスレッド動作へ第一歩。
* **`opt_2.ll`**：並列化 + スケジューリング指定 + 定数事前計算 → **安定性と性能改善**
* **`opt_3.ll`**：`opt_2` にベクトル化 + アンローリングのヒント追加 → **最も高性能な形態**

---

</details>
