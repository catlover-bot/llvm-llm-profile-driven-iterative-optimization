<details><summary>c</summary>

---

##  **ベースライン: `gemver.c`**

* 処理内容（4段階）：

  1. `A[i][j] += u1[i] * v1[j] + u2[i] * v2[j]`
  2. `x[i] += beta * A[j][i] * y[j]`
  3. `x[i] += z[i]`
  4. `w[i] += alpha * A[i][j] * x[j]`
*  並列化なし（全て逐次）
*  `#pragma scop` による最適化スコープあり（Polly対応）
*  SIMD/vector 指示なし

---

##  `opt_1.c` の違い【OpenMP 導入 + 演算一体化】

*  `#pragma omp parallel for private(j)` 各ループに導入
*  `x[i] += beta * temp + z[i]` に再構成 → 2段階目と3段階目を合体
*  `w[i] += ...` などにして蓄積形式（+=）で更新
*  PolyBench の `#pragma scop` 削除済み（手動最適化に移行）

>  **opt\_1** = 並列化 + 式の集約によって **スレッド並列性と命令融合性を向上**

---

##  `opt_2.c` の違い【OpenMP + ループ collapse + 分離演算】

*  `#pragma omp parallel for collapse(2)` により `i`,`j` の2重ループをまとめて並列化

  * → **粒度の細かいワークロード分割**
*  `x[i] = beta * temp + z[i]`（非蓄積）
*  他の部分は `opt_1` と同様に temp 変数を使用
*  明示的に `temp_*` を使ったレジスタキャッシュ強化戦略

>  **opt\_2** = ベクトル化誘導と並列化の中間的バランス。**ループ分解と集約演算の両立**

---

##  `opt_3.c` の違い【最終形：分割ループ + 安定並列】

*  `#pragma omp parallel for` 各ステージに導入
*  各 `i` における `temp_x = z[i] + sum(...)` の形 → 元コードに近いが temp 使用
*  蓄積でなく `x[i] = ...`, `w[i] = ...` の明示更新（より安定なメモリアクセス）
*  `collapse(2)` は使用していない → **パフォーマンスより可搬性と確実性を重視**

>  **opt\_3** = 並列化の安定性を重視した構造。**可読性 + 並列性のハイブリッド**

---

##  比較まとめ表

| 特徴                     | `gemver.c` | `opt_1`              | `opt_2`            | `opt_3`               |
| ---------------------- | ---------- | -------------------- | ------------------ | --------------------- |
| OpenMP 並列化             | ❌          | ✅ `parallel for` 各段階 | ✅ `collapse(2)` 使用 | ✅ 各段階に `parallel for` |
| `x[i]` の更新形式           | `+=`       | `+=` → `temp + z[i]` | `=` （temp + z\[i]） | `=` （temp + z\[i]）    |
| `w[i]` の更新形式           | `+=`       | `+=`                 | `=`                | `=`                   |
| `#pragma scop`         | ✅          | ❌                    | ❌                  | ❌                     |
| 演算の一体化 (`z[i]`組込)      | 分離         | ✅ 組み込み済み             | ✅ 組み込み済み           | ✅ 組み込み済み              |
| ループ再構成 (`collapse(2)`) | ❌          | ❌                    | ✅                  | ❌                     |

---

##  結論

* **opt\_1**：最小限の変更で並列化と式融合を加えた高速化入門
* **opt\_2**：ループ collapse により並列処理粒度を細かく調整、キャッシュ親和性も意識
* **opt\_3**：安定動作を重視し、OpenMP を自然な粒度で適用した完成形

---

</details>
