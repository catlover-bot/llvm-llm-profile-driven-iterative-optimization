<details><summary>c</summary>


---

##  **ベースライン：3mm.c**

### 処理概要:

* `E[i][j] = A[i][k] * B[k][j]`
* `F[i][j] = C[i][k] * D[k][j]`
* `G[i][j] = E[i][k] * F[k][j]`
  すべてのループはネストされた形で `#pragma scop ... #pragma endscop` に包まれており、最適化前提のスコープ明示。

---

##  `opt_1.c` の違い

*  各ループに **OpenMP の `#pragma omp parallel for`** を追加。
*  各ステージ（E, F, G）の計算が並列実行される。
*  **ループブロッキングなし**、ベクトル化ヒントなし。

>  `opt_1` = **基本的なマルチスレッド並列化版**。シンプルで効果的。

---

##  `opt_2.c` の違い

*  **OpenMP + ループブロッキング（タイル化）**

  * `block_size = 32` でループ分割。
  * `ii, jj, kk` 外側ループ + 内側 `i,j,k` による **ブロック処理**。
*  `#pragma omp parallel for` は **各ループに適用**。
*  `collapse(2)` 指定はなし（並列度が限定される場合あり）。

>  `opt_2` = 並列化に加え、**キャッシュ局所性を意識した高速化構造**。

---

##  `opt_3.c` の違い

*  `opt_2` と構造はほぼ同一。
*  **`#pragma omp parallel for collapse(2)`** が登場。

  * 2次元ループを同時並列展開 → より高い並列度と粒度の調整。
*  ループ変数も `private(i, j, k, ii, jj, kk)` に指定。
*  メモリアクセスパターンは同一、構造最適化の強化に特化。

>  `opt_3` = **最大スレッド並列性 + キャッシュ最適**を追求したバージョン。

---

##  比較まとめ表

| 項目            | `3mm.c` | `opt_1.c`       | `opt_2.c`          | `opt_3.c`                     |
| ------------- | ------- | --------------- | ------------------ | ----------------------------- |
| 並列化           | ❌       | ✅ `#pragma omp` | ✅ `omp + blocking` | ✅ `omp + blocking + collapse` |
| ループブロッキング     | ❌       | ❌               | ✅ `ii/jj/kk`ブロック化  | ✅ 同様                          |
| ループcollapse指定 | ❌       | ❌               | ❌                  | ✅ `collapse(2)`で並列粒度拡張        |
| メモリ局所性        | ×（未最適）  | ×               | ◎ キャッシュ効率向上        | ◎ 同上                          |
| 実行効率見込み       | 🚫 低い   | 🆗              | ✅ 高い               | ✅✅ 最高クラス                      |

---

##  結論

* **opt\_1**: 簡単な並列化のみ → 実装は楽、恩恵は限定的。
* **opt\_2**: 並列化 + ブロッキング → 実行性能とキャッシュ効率の両立。
* **opt\_3**: opt\_2 に collapse 追加 → 並列スケジューリング最適。
</details>

<details><summary>ll</summary>

---

##  **ベースライン（base.ll）特徴**

* 全ループ構造は**逐次実行**。
* `alloca`, `load`, `store`, `mul`, `add`など基本命令のみ。
* `!llvm.loop.vectorize`, `!llvm.loop.unroll` などの**メタデータなし**。
* OpenMPやSIMD展開などの**並列・最適化ヒントなし**。

>  素直な逐次実行構造で最適化は施されていない。

---

##  `opt_1.ll` の違い

* 各ループが**OpenMP並列化**され、`__kmpc_fork_call`や`__kmpc_for_static_init`が出現。
*  `@.omp_outlined.*` 関数によって各カーネルが分離（outline化）されており、OpenMP実行の形式に変換。
*  ベクトル化メタデータはなし。
*  ループブロッキング・アンローリングの痕跡もなし。

>  `opt_1.ll` = **マルチスレッド化されたが、命令レベルの最適化なし**。

---

##  `opt_2.ll` の違い

*  `opt_1`と同様のOpenMP並列化あり（`__kmpc` 系呼び出し、outline 関数）。
*  **ループ内に `ii`, `jj`, `kk` のブロック変数が存在**。
*  LLVM IR内でも**ループネストの分割が明確に観察可能**。
*  ブロッキングによる\*\*`load`/`store`の局所性改善\*\*が意図されている。
*  依然として `!llvm.loop.vectorize` は付与されていない。

>  `opt_2.ll` = 並列化 + **キャッシュ効率重視のブロッキング最適化**。

---

##  `opt_3.ll` の違い

*  `opt_2.ll` の最適化を**完全継承**。
*  追加でループ構造に以下のメタデータが付与：

  * `!llvm.loop.vectorize.enable = true`
  * `!llvm.loop.unroll.enable = true`
  * `!llvm.loop.unroll.count = N`（存在する場合）
*  `collapse(2)` に相当するループが1つの `omp_outlined` に統合されている可能性あり（フラット構造）。

>  `opt_3.ll` = 並列化 + ブロッキング + **ベクトル化 + アンローリングヒント**付き = **最も高性能を狙ったLLVM IR**

---

## 🔬 LLVM IR 観点比較表

| 観点                           | base.ll | opt\_1.ll | opt\_2.ll        | opt\_3.ll                  |
| ---------------------------- | ------- | --------- | ---------------- | -------------------------- |
| OpenMP (`__kmpc_*`) 呼出       | ❌       | ✅         | ✅                | ✅                          |
| Outline 関数 (`.omp_outlined`) | ❌       | ✅         | ✅                | ✅                          |
| ループブロッキング                    | ❌       | ❌         | ✅ (`ii, jj, kk`) | ✅ (`ii, jj, kk`)           |
| Vectorize メタデータ              | ❌       | ❌         | ❌                | ✅ `!llvm.loop.vectorize.*` |
| Unroll メタデータ                 | ❌       | ❌         | ❌                | ✅ `!llvm.loop.unroll.*`    |

---

##  結論

* **`opt_1.ll`**：マルチスレッド導入で基本並列化。
* **`opt_2.ll`**：OpenMP + ループブロッキングによる局所性強化。
* **`opt_3.ll`**：opt\_2 にベクトル化・アンローリングメタデータを追加 → **最終形態に近いIR最適化**。

---

</details>
