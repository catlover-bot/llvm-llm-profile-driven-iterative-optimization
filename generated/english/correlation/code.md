<details><summary>c</summary>

---

##  **元実装：`correlation.c` の構造**

### ステージ分割：

1. `mean[j] = 平均(data[*,j])`
2. `stddev[j] = √(分散(data[*,j]))`
3. `data[i][j] = 標準化`
4. `corr[i][j] = Σ_k data[k][i] * data[k][j]`

### 特徴：

*  並列化なし（逐次ループ）
*  ベクトル化なし
*  不要な `sqrt` 再計算あり（1回だけで済む）

---

##  `opt_1.c` の違い【変化なし】

*  `correlation.c` と完全同構造
*  変数宣言 (`int i, j, k`) のみローカル
*  並列化・SIMD・高速化一切なし

>  **opt\_1 = リファクタのみの無最適化版**

---

##  `opt_2.c` の違い【コード簡略化】

*  `stddev[j]` の near-zero 対応を三項演算子化

  ```c
  stddev[j] = stddev[j] <= eps ? 1.0 : stddev[j];
  ```
*  `sqrt_fn` を逆数に一度だけ計算（冗長計算削減）
*  並列化・SIMD 対応なし

>  **opt\_2 = 演算回数と冗長条件分岐の簡素化（小改善）**

---

##  `opt_3.c` の違い【演算削減 + ループ係数前計算】

### 主な最適化：

*  `inv_sqrt_fn = 1.0 / sqrt(float_n)` 事前計算 → 再利用
*  `factor = i / M` を `init_array()` で事前計算しデータ生成簡略化
*  `data` 標準化時の定数を先に外に出して除算を減らす
*  並列化なし（OpenMP不使用）
*  SIMD pragma なし

>  **opt\_3 = 定数・係数の事前計算によりループ内計算量を削減**

---

##  比較表

| 最適化観点                 | `correlation.c` | `opt_1` | `opt_2`    | `opt_3`                |
| --------------------- | --------------- | ------- | ---------- | ---------------------- |
| 並列化（OpenMP）           | ❌               | ❌       | ❌          | ❌                      |
| SIMD化 / ベクトル命令        | ❌               | ❌       | ❌          | ❌                      |
| 平均・標準偏差ループ改善          | ❌               | ❌       | ✅ 三項条件式簡素化 | ✅ 定数分離・除算削減            |
| `inv_sqrt_fn` 事前計算    | ❌               | ❌       | ✅          | ✅                      |
| 初期化式 `data[i][j]` 最適化 | ❌               | ❌       | ❌          | ✅ `factor*i + j` 形式簡略化 |

---

##  結論

* **opt\_1**：リファクタのみ。実行性能は base と同等
* **opt\_2**：条件演算とループ定数を明示化し、**軽微な演算削減**
* **opt\_3**：計算量の削減が最も顕著、**計算式の効率化が進んだ構成**

---

</details>

<details><summary>ll</summary>

---

##  **base.ll（オリジナル構造）**

*  `__kmpc_*` 無し → 並列化なし
*  `!llvm.loop.vectorize.enable` メタなし → 自動ベクトル化不可
*  SIMD命令（`<N x float>`）無し
*  `load`, `fadd`, `fmul`, `sqrt` 等の基本浮動小数点演算で構成
*  `i`, `j`, `k` 三重ループ構造で `corr[i][j] += data[k][i]*data[k][j]`

---

##  `opt_1.ll` の違い【構造変化なし】

*  `base.ll` とほぼ一致
*  SIMD命令なし
*  `llvm.sqrt.f32` の再利用無し（再計算あり）
*  ベクトル化メタなし

>  **opt\_1.ll** = `base.ll` と同一構造、構文整理のみ

---

##  `opt_2.ll` の違い【計算式再構成】

*  条件演算：`cmp`, `select` により `stddev[j] <= eps ? 1.0 : stddev[j]`
*  `sqrt` 結果を逆数として `fmul` 構成
*  SIMD命令無し
*  ループ構造・アクセス順変更なし
*  `fadd`/`fmul` の最小命令構成で中間値 reuse

>  **opt\_2.ll** = 条件制御と平方根逆数処理の**再構成IR**

---

##  `opt_3.ll` の違い【定数事前計算 + 冗長除去】

*  `inv_sqrt_fn = 1.0 / sqrt(float_n)` → `llvm.sqrt.f32` + `fdiv` で1回のみ
*  初期化時に `factor * i + j` → `fmul` + `fadd` → `store`
*  `load data[...]`, `sub`, `mul`, `fadd` 明確に整理された演算構成
*  `!llvm.loop.vectorize.enable` なし → 自動SIMDは未有効
*  SIMD命令（`<4 x float>`など）出現なし

>  **opt\_3.ll** = 不変定数計算の外出し＋ループ内除算削減による**演算最小化**

---

##  LLVM IR 比較表

| 特徴                      | base.ll | opt\_1.ll | opt\_2.ll      | opt\_3.ll            |
| ----------------------- | ------- | --------- | -------------- | -------------------- |
| OpenMP 並列（`__kmpc_*`）   | ❌       | ❌         | ❌              | ❌                    |
| SIMD命令（`<4 x float>`等）  | ❌       | ❌         | ❌              | ❌                    |
| ベクトル化メタ (`vectorize.*`) | ❌       | ❌         | ❌              | ❌                    |
| 条件制御（`stddev <= eps`）   | ❌       | ❌         | ✅ `cmp+select` | ✅                    |
| `sqrt` + `1/sqrt` 最適化   | ❌       | ❌         | ✅ 一部再利用        | ✅ 1回のみ計算             |
| `data[i][j]` 初期化最適化     | ❌       | ❌         | ❌              | ✅ `factor*i + j` を明示 |

---

##  結論

* **opt\_1.ll**：構文調整レベル、ベースと同等
* **opt\_2.ll**：条件分岐や平方根逆数の冗長排除 → **中規模演算最適化**
* **opt\_3.ll**：**演算式事前計算・ループ軽量化の最高度最適化構造**

---


</details>
