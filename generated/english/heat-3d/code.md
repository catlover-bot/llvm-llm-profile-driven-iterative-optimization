<details><summary>c</summary>

---

##  オリジナル：`heat-3d.c`【ベースライン】

* **手法：** 完全なスカラー三重ループ
* **並列化：** なし
* **最適化：** 定数ベース計算 (`0.125`, `2.0`) をそのまま演算内で繰り返す
* **データアクセス：** 直接アクセス、キャッシュ無視

---

##  `opt_1`：**IVDEPベースの依存回避**

*  追加：`#pragma GCC ivdep` によりコンパイラに**依存性なしと指示**
*  限定的最適化：依然として**配列要素へ直接アクセス**
*  明示的な変数抽出や並列化は未使用

>  **主目的：** ベクトル化可能性をコンパイラに通知してループを高速化
> → SIMDやループアンローリングの基礎足がかり

---

##  `opt_2`：**演算局所化・キャッシュヒット向上**

*  `A[i][j][k]` や `A[i±1][j][k]` を一時変数へ展開：

  ```c
  DATA_TYPE a_ip1jk = A[i+1][j][k];
  ```
*  除算対象となる多項式が**一時変数化され再利用**
*  `#pragma GCC ivdep` 継続使用で**SIMD展開誘導**
*  並列化 (`OpenMP`) は未導入

>  キャッシュ効率 + 演算最適化により**単一スレッドで高速化**を目指す構成

---

##  `opt_3`：**OpenMP並列化 + ループ結合最適化**

*  `#pragma omp parallel for collapse(2)` による**2重ループ並列化**
*  `collapse(2)`により `i`, `j` をフラットにして負荷分散
*  `ivdep` や一時変数展開は未使用（opt\_2との融合はしていない）
*  各スレッドが**A/B の並列ブロック更新**を行う

>  マルチコア環境で最も高速なバージョン。ただしスレッド数依存性あり。

---

##  最適化まとめ表

| 機能           | base | opt\_1 | opt\_2 | opt\_3       |
| ------------ | ---- | ------ | ------ | ------------ |
| `ivdep`      | ❌    | ✅      | ✅      | ❌            |
| 一時変数による演算展開  | ❌    | ❌      | ✅      | ❌            |
| OpenMP 並列化   | ❌    | ❌      | ❌      | ✅            |
| ループ collapse | ❌    | ❌      | ❌      | ✅ (`i`, `j`) |
| キャッシュ局所性改善   | ❌    | ❌      | ✅      | ❌            |
| SIMD対応ヒント    | ❌    | ✅      | ✅      | ✅（間接的）       |

---

## 🏁 結論

| シナリオ                       | 推奨      |
| -------------------------- | ------- |
|  **スレッド多めの環境（マルチコアCPU）** | `opt_3` |
|  **シングルスレッド or 小規模環境**   | `opt_2` |
|  **コンパイラベースの軽量最適化のみ**    | `opt_1` |
|  **元の構造確認・教育用**          | `base`  |


</details>

<details><summary>ll</summary>

---

##  `heat-3d_opt_base.ll`

*  `__kmpc_*` や `omp.outlined.*` なし → 並列化ゼロ
*  `!llvm.loop.vectorize.enable` メタなし
*  `load` 命令すべて `align 8`（低アラインメント）
*  明示的なスカラーループ、単一命令列 `fadd`, `fmul` のみ

>  完全に素直な逐次命令列 → コンパイラ最適化未考慮

---

##  `opt_1.ll`

*  `!llvm.loop.vectorize.enable = true` あり
  → `ivdep` に対応したベクトル化ヒントが追加
*  `__kmpc_*` 無し（並列化ナシ）
*  `align`, `nontemporal`, `fast-math` フラグ無し

>  **SIMD指示だけが追加されたバージョン**
> ベクトル命令化される可能性が高まるが、依然としてメモリ最適化は未実施

---

##  `opt_2.ll`

*  `vectorize.enable`, `interleave.count`, `vectorize.width` あり
  → コンパイラにループ展開・SIMD展開を明示
*  `load` が一時変数に保持される構造をIR内で展開
*  並列化構造（OpenMP）は無し
*  命令列が `fadd`→`fmul`→`store` に整理済（IR上で演算効率高）

>  **IRレベルでの演算展開最適化 + SIMD前処理が完了済**

---

##  `opt_3.ll`

*  `__kmpc_fork_call` → OpenMP並列構造アリ
*  `omp.outlined.*` 関数生成 → スレッド単位で分離されてる
*  `vectorize.enable` は明示的にナシ（ただしIR構造的にベクトル化されやすい）
*  `collapse(2)` 構造によるフラットループ展開済み

>  **スレッドによるループ分担が実装された並列版IR**
> コンパイラによってはこれにSIMDまで重ねて適用可能な構造

---

##  比較まとめ表

| 機能                              | base.ll | opt\_1.ll | opt\_2.ll | opt\_3.ll |
| ------------------------------- | ------- | --------- | --------- | --------- |
| OpenMP (`__kmpc_*`)             | ❌       | ❌         | ❌         | ✅         |
| `!llvm.loop.vectorize.enable`   | ❌       | ✅         | ✅         | ❌         |
| `vectorize.width`, `interleave` | ❌       | ❌         | ✅         | ❌         |
| 一時変数展開 (`%tmp`, `%v`)           | ❌       | ❌         | ✅         | 部分的       |
| `align`, `nontemporal` 指定       | ❌       | ❌         | ❌         | ❌         |

---

## 結論：**opt\_2.ll = SIMD最適化に最も近いIR**, **opt\_3.ll = 並列処理IR**

*  **opt\_2.ll：** LLVMベクトル化パスに最適。高密度演算が可能な形に整理済。
*  **opt\_3.ll：** マルチスレッドに最適。ループ分散済でスレッド化対象として優秀。

---


</details>
