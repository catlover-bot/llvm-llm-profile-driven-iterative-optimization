<details><summary>c</summary>

---

##  対象一覧：

| ファイル      | 説明                              |
| --------- | ------------------------------- |
| `lu.c`    | 元の PolyBench ルーチン               |
| `opt_1.c` | 初段階ベース最適化                       |
| `opt_2.c` | 演算順序最適化                         |
| `opt_3.c` | `memcpy`, 局所変数最適化含むベクトル/キャッシュ強化 |

---

##  **1. 初期化関数 (`init_array`) の違い**

###  `lu.c` / `opt_1`：

```c
B[r][s] += A[r][t] * A[s][t];  // 対称行列 A*A^T を構築
```

* 行・列両方向にアクセス → キャッシュミス発生しやすい
* PolyBench標準スタイル（ベンチマーク用途）

###  `opt_2`：

```c
At = A[t][r]; 
B[r][j] += At * A[t][j];  // 転置の明示的展開を回避
```

* 転置アクセスの再利用により**再利用性向上**
* `At` は列成分をキャッシュ保持 → キャッシュミス低減
* ただし **同じ `B[r][j]` に複数回アクセス** → ストア命令競合の可能性

###  `opt_3`：

```c
memcpy(At, A[t], sizeof(DATA_TYPE) * n);
...
B[r][t] = Σ(At[j] * A[t][j]);  // 1行対1行の積
```

* **全行を1次元テンポラリに保持し**、1回の内積演算で転置処理
* `B[r][t]` は `r` に対して独立 → **並列化しやすい構造**
* 計算量 O(n³)は維持だが**メモリアクセス効率化**に貢献

---

##  **2. LU カーネル (`kernel_lu`) の違い**

全バージョン共通で以下のループ構造を持つ：

```c
for i = 0 to n
  for j = 0 to i
    for k = 0 to j
      A[i][j] -= A[i][k] * A[k][j];
    A[i][j] /= A[j][j];

  for j = i to n
    for k = 0 to i
      A[i][j] -= A[i][k] * A[k][j];
```

 **違いなし**
→ 最適化は `kernel_lu` より **初期化 (`init_array`) 側に集中**
→ コンパイラによる SIMD 展開やループ変換で効果を受けやすい

---

##  統合比較まとめ

| 比較項目     | `lu.c`（ベース） | `opt_1` | `opt_2`      | `opt_3`                |
| -------- | ----------- | ------- | ------------ | ---------------------- |
| 行列変換構造   | `A*A^T`     | 同上      | 行ベース積（内積）に置換 | `memcpy` によるローカルベクトル内積 |
| アクセス最適化  | ❌           | ❌       | ✅（転置回避）      | ✅✅（局所性強化）              |
| ベクトル展開容易 | 中           | 中       | 高            | 最高（ループ独立性高）            |
| キャッシュ効率  | 低           | 低       | 中（転置削減）      | 高（ローカル化）               |

---


</details>

<details><summary>ll</summary>
  
---

##  `opt_base.ll` / `opt_1.ll`

*  `!llvm.loop.vectorize.enable` 無し → **ベクトル化不可**
*  `memcpy`, `tmp` 配列展開無し
* `load` / `store` 命令はシンプルな `getelementptr` 経由
* `init_array` の行列初期化ループはスカラーループのまま

>  **純粋ベース構造。最適化を一切含まない。**

---

##  `opt_2.ll`

*  `!llvm.loop.vectorize.enable = true` 登場 → ベクトル展開許可
*  `!llvm.loop.interleave.count = 4` や `vectorize.width = 4` → **SIMD処理指示**
* 中間値 `%tmp1`, `%tmp2` → `fadd`, `fmul`, `load` による展開
* `init_array` 部で **行と列アクセスが分離**されており、IR構造が展開されやすい

>  **SIMD適用可能な構造に変形されている（転置不要化ループ）**

---

##  `opt_3.ll`

*  上記すべて＋`memcpy` 表現検出 (`llvm.memcpy.p0i8.p0i8.i64`)
  → 行全体をテンポラリ配列にコピーしてベクトル化可能に
*  `loop.vectorize.enable = true` も維持
*  `loop.unroll.count`, `unroll.enable = true` → **ループアンローリング**
*  演算部は `fmul`, `fadd`, `fsub` がレジスタ変数間で完結

>  IRでは**局所メモリ展開 + ベクトル化 + アンローリング**の3段構え！

---

##  総括マトリクス

| 機能/構文                      | base.ll / opt\_1.ll | opt\_2.ll | opt\_3.ll |
| -------------------------- | ------------------- | --------- | --------- |
| `vectorize.enable = true`  | ❌                   | ✅         | ✅         |
| `loop.interleave.count`    | ❌                   | ✅         | ✅         |
| `llvm.memcpy.*`            | ❌                   | ❌         | ✅         |
| レジスタ間演算展開 (`fmul`, `fadd`) | 一部                  | ✅         | ✅         |
| アンローリング (`unroll.count`)   | ❌                   | ❌         | ✅         |

---

##  結論 
*  `opt_base` / `opt_1`: 比較用ベース
*  `opt_2`: 転置最適化によるSIMD指示あり（良好）
*  `opt_3`: **最高効率な局所性・ループ展開・ベクトル命令融合**


</details>
