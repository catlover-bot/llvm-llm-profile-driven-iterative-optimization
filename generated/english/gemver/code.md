<details><summary>c</summary>

---

###  元コード `gemver.c` の特徴【基準】

* **逐次実装**：OpenMP等の並列構文は一切なし
* `x[i]` の更新が2段階（逐次計算＋z加算）
* ループ分割はされておらず、密結合な計算
* `_PB_N` マクロによるループバウンド最適化（Polybench流）

---

##  `opt_1.c`：OpenMP導入 + 構造単純化

* `#pragma omp parallel for` によって **全ループを並列化**
* `x[i] += ...` や `w[i] += ...` の逐次加算をなくし、**再代入形式に変更**
  → 可視的に `x[i] = beta * temp + z[i]`（1発書き）へ変更済
* `A[i][j] += ...` の形は変更なし、同様に u1\[i] や u2\[i] を都度参照

 **最適化ポイント**：

* 逐次加算 → 明示的な結果変数代入でスカラーレジスタ使用促進
* 並列化指示の追加により OpenMP 対応コンパイラで並列ループ化可能に

---

##  `opt_2.c`：OpenMP + データアクセス改善

* `opt_1`とほぼ同様の並列ループ構造
* **ループ内変数の除算除去無し**（例：`(i+1)/fn` を毎回演算）
  → 計算的には冗長性あり
* `A[i][j] = (i * j % n) / n` → 分母除算が定数除算に最適化可能

 **違いは主に初期化関数における数式計算の簡略度**

* `init_array` において `opt_1` よりも式変形されていないため、わずかに非効率

---

##  `opt_3.c`：OpenMP + **レジスタ最適化の適用**

* `u1[i]`, `u2[i]` → `u1_i`, `u2_i` として **ループ外でキャッシュ変数化**
* `A[i][j] += u1_i * v1[j] + u2_i * v2[j];` により **ループ内アクセスの削減**
* 全ループ `#pragma omp parallel for` 明記（並列最適化あり）

 **opt\_3 はベスト：キャッシュ効率 + スレッド化**

---

##  比較まとめ

| 特徴                     | gemver.c | opt\_1    | opt\_2    | opt\_3            |
| ---------------------- | -------- | --------- | --------- | ----------------- |
| OpenMP 指令              | ❌        | ✅         | ✅         | ✅                 |
| `x[i] +=` 分離           | あり       | 再代入化      | 再代入化      | 再代入化              |
| `u1[i]`/`u2[i]`のキャッシュ化 | ❌        | ❌         | ❌         | ✅ `u1_i`, `u2_i`化 |
| 初期化最適化                 | 中間       | 良         | 弱（毎回除算）   | 良（除算キャッシュ済）       |
| 内部ループスケジューリング          | 逐次       | static 並列 | static 並列 | static 並列         |

---

##  結論

* **opt\_1**：OpenMP導入が主な改善点。基礎的な並列化。
* **opt\_2**：opt\_1とほぼ同等。初期化コードの冗長さあり。
* **opt\_3**：**最も高効率**なバージョン。メモリアクセス最小化＋並列実行向けに最適化されている。

---

</details>

<details><summary>ll</summary>

---

##  `gemver_opt_base.ll`（元コード）

*  `!llvm.loop.vectorize.enable` などベクトル化メタ無し
*  OpenMP構造も無し（`__kmpc_fork_call` 不在）
*  ループ構造はネストされた `i`, `j` の二重構造
*  `load`, `store`, `fadd`, `fmul` が中心のスカラー命令構成

>  **プレーンIR。LLVM最適化前の静的な逐次表現**

---

##  `opt_1.ll`（OpenMP追加）

*  `__kmpc_fork_call`, `__kmpc_for_static_init_*` などの出現 → OpenMP有効
*  `omp.outlined.*` 関数が生成 → スレッド単位分離
*  SIMDベクトル命令なし（スカラー命令継続）
*  `!llvm.loop.vectorize.enable` メタ無し → LLVMの自動ベクトル化対象外

>  **opt\_1 = 並列ループ化（OpenMP）されたIR。ベクトルヒントは未対応**

---

##  `opt_2.ll`（OpenMP + 軽度メタ追加）

*  OpenMP構造は維持（`kmpc_*`, `omp.outlined.*`）
*  一部ループに `!llvm.loop.vectorize.enable = true` メタ付加あり
*  ベクトル命令自体（`<N x float>`）は未展開
*  `x[i]` や `w[i]` に対する更新が逐次から再代入形式に整理済

>  **opt\_2 = LLVMの自動ベクトル化パスを通すためのヒント付きIR**

---

##  `opt_3.ll`（OpenMP + ベクトル化準備完備）

*  全主要ループに `!llvm.loop.vectorize.*` メタ付与（`enable`, `width`, `interleave`）
*  `load`, `store` に `align 32` 等の明示アラインメント属性あり
*  `temp` 変数の導入と `u1[i]`, `u2[i]` の `load` 最小化確認（スカラーレジスタ変数で保持）
*  ただし **ベクトル命令の実展開（例：`fmul <4 x float>`）はまだ無し**

>  **opt\_3 = LLVMが最大限最適化可能なIR。SIMD変換直前の最高段階**

---

##  比較表

| 特徴                        | base.ll | opt\_1.ll | opt\_2.ll | opt\_3.ll                         |
| ------------------------- | ------- | --------- | --------- | --------------------------------- |
| OpenMP (`__kmpc_*`)       | ❌       | ✅         | ✅         | ✅                                 |
| `omp.outlined` 関数         | ❌       | ✅         | ✅         | ✅                                 |
| `vectorize.enable = true` | ❌       | ❌         | ✅（一部）     | ✅（完全）                             |
| ベクトル命令 `<N x float>`      | ❌       | ❌         | ❌         | ❌（展開直前構造）                         |
| `load/store` のアラインメント     | 通常      | 通常        | 通常        | ✅（`align 32`, `nontemporal` 属性付き） |
| `temp`, `u1_i` などの再利用構造   | ❌       | 一部        | 一部        | ✅                                 |

---

##  総括

* **opt\_1.ll**：OpenMP並列化された IR。逐次ループがマルチスレッド化可能に。
* **opt\_2.ll**：ベクトル化のためのヒント（メタ）付き構造。構文の再整理も。
* **opt\_3.ll**：最適な `alias` 管理・アラインメント・loop metadata を全導入済。**LLVM SIMD変換準備が完璧**

---

</details>
