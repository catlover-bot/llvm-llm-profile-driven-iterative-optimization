<details><summary>c</summary>


---

##  **元実装：`cholesky.c` の構造**

### `init_array`

* `A[i][j] = (-j % n)/n + 1`, `A[i][i] = 1`
* 正定値行列化：

  ```
  B[r][s] += A[r][t] * A[s][t]
  A = B
  ```
* 三重ループ（t, r, s）

### `kernel_cholesky`

* 対角・非対角要素を手動計算する形式：

  ```c
  for (i)
    for (j < i)
      A[i][j] -= Σ_k A[i][k] * A[j][k];
      A[i][j] /= A[j][j];
    A[i][i] -= Σ_k A[i][k]^2;
    A[i][i] = sqrt(A[i][i]);
  ```
*  メモリ再利用最適化なし
*  並列化なし
*  PolyBench `#pragma scop` で囲まれた構造

---

##  `opt_1.c` の違い【ベースに近い + B = A\*Aᵗ 明示的構造】

*  `A` は `(r, t)` と `(s, t)` を使い、`B[r][s] = A[r][t] * A[s][t]`
*  `init_array()`の内部構造が明示的かつ正規化
*  `kernel_cholesky()` は完全に同じ構造【baseと完全一致】
*  PolyBenchスコープ完備
*  並列化なし・命令数最適化なし

>  **opt\_1 = baseと同じ処理だが、配列コピー方式がより明確に書かれている。**

---

##  `opt_2.c` の違い【列⇄行転置の最適化】

* `init_array()` にて `A[r][t] * A[s][t]` → `A[r][t] * A[t][s]` 相当へ変更
* A列ベースから行ベースに再構成して `B` 生成：

  ```c
  B[r][s] += A[r][t] * A[s][t]; → A[r][t] * A[t][s]（転置っぽい）
  ```
*  `kernel_cholesky()` は base 同様
*  計算順序を変更し、**キャッシュヒット率を改善**
*  並列化なし・SIMD命令なし

>  **opt\_2 = 転置型アクセスでキャッシュ局所性を高めた実装**

---

##  `opt_3.c` の違い【列キャッシュ最適化】

* `init_array()` で A\[t]（列全体）を `A_col[]` にコピーしてから積算：

  ```c
  memcpy(A_col, A[t], ...)
  B[r][s] += A_col[r] * A_col[s];
  ```
*  **t列に対するアクセスをメモリ連続化 → キャッシュ効率UP**
*  `kernel_cholesky()` は base と同一
*  並列処理は無し、SIMD命令やOpenMPも無し

>  **opt\_3 = 列ベース処理をバッファリングすることでメモリ最適化を意識した設計**

---

##  構造比較表

| 特徴                    | `base.c`           | `opt_1.c` | `opt_2.c`             | `opt_3.c`                 |
| --------------------- | ------------------ | --------- | --------------------- | ------------------------- |
| 行列初期化方式               | A\[r]\[t]A\[s]\[t] | 同上        | 転置型 `A[r][t]*A[t][s]` | `A[t]` → `A_col[]` バッファ使用 |
| kernel\_cholesky 本体構造 | ✅                  | ✅         | ✅                     | ✅                         |
| PolyBench準拠           | ✅                  | ✅         | ✅                     | ✅                         |
| 並列化（OpenMP等）          | ❌                  | ❌         | ❌                     | ❌                         |
| キャッシュ最適化              | ❌                  | ❌         | ✅（転置）                 | ✅（列キャッシュ）                 |
| SIMD化                 | ❌                  | ❌         | ❌                     | ❌                         |

---

##  総括

* **opt\_1**：baseに忠実、構造が明示的でコードが読みやすい
* **opt\_2**：転置型アクセスによりキャッシュ効率を改善
* **opt\_3**：列バッファを導入して最も実践的なキャッシュ効率化設計

---

</details>

<details><summary>ll</summary>

---

##  **base.ll（元構造）**

*  `__kmpc_*` 呼び出し無し → OpenMP 並列化なし
*  SIMD命令（`<N x double>`）なし
*  `!llvm.loop.vectorize.enable` メタ無し → 自動ベクトル化不可
*  `i, j, k` ループ構造、`A[i][j] -= A[i][k] * A[j][k]`
*  `sqrt`命令含む（`llvm.sqrt.f64`）

---

##  `opt_1.ll` の違い【構造的明示のみ】

*  IR構造は `base.ll` とほぼ一致
*  OpenMP / vectorize メタ無し
*  メモリアクセス再構成・ループ融合などなし
*  行列初期化部の配列コピー `memcpy` や `store` が明示化されている程度

>  **opt\_1.ll** = `base.ll`と同等の構造、**明示化されただけのIR**

---

##  `opt_2.ll` の違い【転置アクセス最適化】

*  配列アクセスパターンが `A[r][t] * A[t][s]` に変化（転置アクセス）
*  `load` 命令の順序が改善 → **ループ内連続アクセスによるキャッシュ効率向上**
*  OpenMP / vector メタなし
*  `llvm.fmul`, `llvm.fadd` で `B[r][s]` 構築を効率化

>  **opt\_2.ll** = 転置ベースによる**メモリアクセス局所性向上**

---

##  `opt_3.ll` の違い【列キャッシュ展開型】

*  `A[t]` を一時配列 `A_col` にコピー（`memcpy`, `alloca`）
*  `A_col[r] * A_col[s]` の構造で `B[r][s]` を更新
*  `A_col` は stack buffer → 連続領域へのアクセス最適
*  並列化無し、`vectorize` メタ無し
*  メモリアクセス数とキャッシュミスを最小限に抑えた形状

>  **opt\_3.ll** = 列ベースアクセスを**キャッシュ効率重視に変換**

---

##  比較表（LLVM IR）

| 特徴                          | base.ll   | opt\_1.ll | opt\_2.ll              | opt\_3.ll             |
| --------------------------- | --------- | --------- | ---------------------- | --------------------- |
| OpenMP 並列                   | ❌         | ❌         | ❌                      | ❌                     |
| ベクトル化メタ (`vectorize.*`)     | ❌         | ❌         | ❌                      | ❌                     |
| `A[i][j]` アクセスパターン          | A\[i]\[j] | 同左        | 転置 `A[r][t] * A[t][s]` | 列 `A[t] → A_col[r/s]` |
| `sqrt` 命令 (`llvm.sqrt.f64`) | ✅         | ✅         | ✅                      | ✅                     |
| メモリレイアウト最適化                 | ❌         | ❌         | ✅（転置）                  | ✅（列キャッシュ）             |

---

##  結論

* **opt\_1.ll**：構造変化なし、ベースと同様
* **opt\_2.ll**：転置型アクセスにより**ループ内連続アクセス最適化**
* **opt\_3.ll**：列データを連続バッファに展開 → **最もキャッシュヒット率が高い構造**

---

</details>
