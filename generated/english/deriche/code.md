<details><summary>c</summary>

---

##  **オリジナル（`deriche.c`）**

### 特徴：

*  並列化なし
*  OpenMP不使用
*  全5段階のフィルタ（左右・上下 2pass + 合成）を明示的に逐次処理
*  係数：`a1~a8, b1, b2, c1, c2` 使用（対称性考慮）

---

##  `opt_1.c` の違い【OpenMP粗並列化】

*  各ループに `#pragma omp parallel for private(i, j)` 追加
*  計算式構造そのものは `base` と同様（5フェーズ構成）
*  OpenMP `private` 範囲の過剰指定（ループカウンタ含む必要なし）
*  `i`, `j` のprivate指定は冗長、ローカルで十分

>  **opt\_1 = OpenMP粗粒度導入だがベストプラクティスからは逸脱**

---

##  `opt_2.c` の違い【式簡略化＋OpenMP粒度調整】

*  `exp(-alpha)` を繰り返し使用せず都度計算 → 精度の観点から独立計算保持
*  `private()` 指定なし → 暗黙スレッドスコープを活用（安全）
*  係数は `a1~a4` のみで処理（a5\~a8 削除、重複を除去）
*  構造は `opt_1` と同等、だがよりクリーン

>  **opt\_2 = OpenMP最小干渉・明示最小構文による効率的並列化**

---

##  `opt_3.c` の違い【再利用性最適化 + OpenMP最適】

*  `exp(-alpha)`, `exp(-2.0*alpha)` を**事前変数へ分離**

  ```c
  DATA_TYPE exp_neg_alpha = exp(-alpha);
  DATA_TYPE exp_neg_2alpha = exp(-2.0 * alpha);
  ```
*  演算再利用で `k`, `a1~a4`, `b1`, `b2` の式評価を**最小限に圧縮**
*  OpenMP構造は `opt_2` と同一（シンプルかつ高効率）
*  `c1`, `c2` も定数扱いで冗長削除無し

>  **opt\_3 = 演算再利用性を最優先にした最高効率構造**

---

##  比較表

| 項目                 | base     | opt\_1   | opt\_2     | opt\_3     |
| ------------------ | -------- | -------- | ---------- | ---------- |
| OpenMP導入           | ❌        | ✅ (全ループ) | ✅ (冗長削除)   | ✅ (最小限構文)  |
| `private(i, j)` 明示 | ❌        | ✅ 過剰指定   | ❌          | ❌          |
| 不変式の事前分離           | ❌        | ❌        | ❌          | ✅ `exp`再利用 |
| フィルタ係数冗長排除         | ❌ a1\~a8 | ❌ a1\~a4 | ✅ a1\~a4のみ | ✅ a1\~a4のみ |
| 多方向パス（縦横、逆順）       | ✅        | ✅        | ✅          | ✅          |
| 出力最終計算             | ✅        | ✅        | ✅          | ✅          |

---

## 結論

* **opt\_1**：OpenMPを形式的に導入。スレッドセーフだが過剰な記述
* **opt\_2**：明示を削減しつつ冗長係数を除去。見通し良くクリーンな構造
* **opt\_3**：**演算式再利用最適化**により定数計算量を圧縮。最も計算効率に優れる

---

</details>

<details><summary>ll</summary>

---

##  **base.ll（未最適化構造）**

*  `__kmpc_*` 無し → 並列化されていない
*  `vectorize.enable` メタ無し
*  `<N x float>` SIMD命令無し
*  係数 a1〜a8, b1, b2, c1, c2 をその都度 `fadd`, `fmul` 等で使用
*  `i`, `j` ループに基づく5ステージパイプライン構造（X方向/Y方向 forward/backward）

---

##  `opt_1.ll` の違い【OpenMP挿入 + 係数変化なし】

*  `__kmpc_fork_call` や `__kmpc_for_static_init_4` 出現 → **OpenMP対応**
*  ベクトル命令なし（逐次スカラー演算）
*  各ループに `omp_outlined` 関数で parallel loop が生成されている
*  `a1~a8`, `b1`, `b2`, `c1`, `c2` は都度 `fadd` や `fmul` で評価されており**共通化されていない**

>  **opt\_1.ll = OpenMP対応されたが、演算・係数の再利用は未最適化のまま**

---

##  `opt_2.ll` の違い【OpenMP最適 + 式簡素化】

*  OpenMP構造は `opt_1` と同様
*  `a5〜a8` が削除され、式が `a1〜a4` 中心に再構成されたことがIRでも確認
*  各ステージの `fadd`, `fmul` 構成が **単純化された形に変換**
*  SIMD化なし（vector命令は見当たらず）

>  **opt\_2.ll = 式の再構成とOpenMPの効率化によりパス数と命令数を削減**

---

##  `opt_3.ll` の違い【式の定数分離最適化】

*  `exp(-alpha)` や `exp(-2*alpha)` などの事前計算がIRに `load` された形で確認可能（`alloca` → `store`）
*  `a1~a4`, `b1`, `b2` なども事前に `fdiv` 等で準備されており、ループ内では**再利用される**
*  OpenMP構造は `opt_2` 同様
*  SIMD命令 / `vector.reduce.*` 系なし

>  **opt\_3.ll = 再利用式の定数事前分離によりループ命令数が最少化されたバージョン**

---

##  LLVM IR 比較表

| 特徴                      | base.ll | opt\_1.ll | opt\_2.ll | opt\_3.ll                |
| ----------------------- | ------- | --------- | --------- | ------------------------ |
| OpenMP並列化（`__kmpc_*`）   | ❌       | ✅         | ✅         | ✅                        |
| SIMD命令（`<4 x float>`など） | ❌       | ❌         | ❌         | ❌                        |
| ベクトル化メタ (`vectorize.*`) | ❌       | ❌         | ❌         | ❌                        |
| 式の簡素化（a5〜a8削除）          | ❌       | ❌         | ✅         | ✅                        |
| 定数事前計算                  | ❌       | ❌         | ❌         | ✅ `exp`, `1-b1-b2` など再利用 |
| 演算命令数（ループ内）             | 多       | 多         | 中         | 少                        |

---

##  結論

* **opt\_1.ll**：並列化のみ導入。演算数はbase同様で効率は低い。
* **opt\_2.ll**：構文とパスを整理し、無駄な係数を排除。ループ内容を軽量化。
* **opt\_3.ll**：事前定数化＋OpenMPを併用したIRで**最も効率の高い構造**

---

</details>
