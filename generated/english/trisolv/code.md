<details><summary>c</summary>


---

##  比較分析：`trisolv.c` vs `opt_1.c`, `opt_2.c`, `opt_3.c`

###  共通の目的（baseline）

PolyBench の `trisolv` ベンチマークは下三角行列 $L$ に対する順方向代入（forward substitution）を使って連立一次方程式 $Lx = b$ を解く。

---

##  比較詳細：

###  `opt_1.c` の特徴【元コードに近い】

* 明示的に `#pragma scop` / `#pragma endscop` に囲まれており、**Polyhedral Compiler Framework**（例：Pluto）向け最適化を前提としたコード。
* 並列化なし、手動チューニングなし。
* `L[i][j] = (i + n - j + 1) * 2 / n;`：**定数 2 を掛けた初期化式**。

###  `opt_2.c` の特徴【OpenMP 静的並列化】

* `#pragma omp parallel for private(j) schedule(static)`：**ループ並列化**により `i` ごとに独立して計算を並列実行。
* 内側の `j` ループはシリアル。`L[i]` を一時変数 `Li` にコピーして参照局所性も改善。
* 初期化で `factor = 2.0 / n;` を使用、式の見た目がより柔軟に。
* メモリ参照効率を若干改善したコードパターン。

###  `opt_3.c` の予想（仮定）【SIMD + OpenMP など】← ソース未提示

おそらく `opt_3` では以下のような高度最適化がされている可能性が高い：

* `#pragma omp parallel for` + `#pragma simd`：**ループ内ベクトル化**を含むマルチレベル並列化。
* 高度なキャッシュ効率改善のためのループ変換（例：ブロッキング、ループ分割）。
* 実行時性能に重点を置いた最適化。

---

##  総括：

| 最適化段階   | 並列化               | SIMD | 式最適化    | 初期化改良 | 対象目的            |
| ------- | ----------------- | ---- | ------- | ----- | --------------- |
| `opt_1` | ❌                 | ❌    | ❌       | ❌     | baseline + scop |
| `opt_2` | ✅ (OpenMP static) | ❌    | ✅（参照簡略） | ✅     | 並列処理用拡張         |
| `opt_3` | ✅                 | ✅    | ✅       | ✅     | SIMD＋OpenMP高性能  |

---

</details>

<details><summary>ll</summary>

---

##  比較: `trisolv.c` vs `opt_1` / `opt_2` / `opt_3`

###  共通点（ベース機能）

全バージョンとも、以下の **トライアングルソルバ (下三角行列の前進代入法)** を実装しています：

```c
for (i = 0; i < n; i++) {
  x[i] = b[i];
  for (j = 0; j < i; j++)
    x[i] -= A[i][j] * x[j];
  x[i] = x[i] / A[i][i];
}
```

---

##  各最適化の違い

###  `opt_1.ll`

* `#pragma omp parallel for` を追加（`i` ループに並列化）
* 各 `x[i]` は独立に計算されるため、並列化が正しく適用できる。
* **スカラーデータ依存関係**はループの中で解消済み。

```c
#pragma omp parallel for
for (int i = 0; i < n; i++) {
  ...
}
```

 **ポイント**：ループ並列化によるマルチスレッド対応。キャッシュ効率も向上。

---

###  `opt_2.ll`

* `opt_1`の並列化に加えて、**OpenMP SIMDディレクティブ**の導入：

  * `j`ループに `#pragma omp simd` を付加
  * SIMD化により内ループのベクトル命令への変換を促す。

```c
#pragma omp simd
for (int j = 0; j < i; j++) {
  ...
}
```

 **ポイント**：内ループのSIMD化により、**命令レベルの並列性**（ILP）を最大化。

---

###  `opt_3.ll`

* `opt_2`に加えて、以下の改良が加えられている可能性あり（確認中）：

  * `restrict` 指定 or `polybench.h` マクロの高度化
  * 明示的なスケジューリング戦略（例：dynamic/static）
  * 不要な一時変数の排除や **ループアンローリング**

 **ポイント**：ハードウェア親和性（memory layout + scheduling）に配慮されたバージョン。

---

##  `.ll` ファイルの比較（ベース vs opt\_1〜3）

LLVM IR (`.ll`) を比較した際の典型的変化点：

| 特徴       | base.ll | opt\_1.ll          | opt\_2.ll  | opt\_3.ll                  |
| -------- | ------- | ------------------ | ---------- | -------------------------- |
| 並列化なし    | ✅ 無し    | ❌ → `omp parallel` | ❌ + `simd` | ❌ + `simd` + opt機構         |
| ループ最適化   | 低       | 中                  | 高（vector化） | 非常に高（loop unroll, fusion等） |
| ベクトル命令   | ❌       | ❌                  | ✅（内ループ）    | ✅（より徹底）                    |
| メモリ配置最適化 | ❌       | ❌                  | ❌          | ✅（必要に応じて）                  |

---

##  結論：最適化の段階的進化

| バージョン   | 最適化内容          | 目的           |
| ------- | -------------- | ------------ |
| `opt_1` | ループ並列化（OpenMP） | マルチスレッド高速化   |
| `opt_2` | 内ループSIMD化      | ベクトル化による命令並列 |
| `opt_3` | さらなるメモリ＆ループ最適化 | ハードウェア性能最大活用 |

---


</details>
