<details><summary>c</summary>


---

##  **最適化比較まとめ：syrk.c vs opt\_1 / opt\_2 / opt\_3**

###  共通点：

* **初期化関数 (`init_array`)** や **出力関数 (`print_array`)** に違いはなし。
* `alpha`, `beta`, `C`, `A` などの配列・変数定義も同一。
* PolyBench のベース構造も全く同じ。
* `kernel_syrk()` が唯一の差分ポイント。

---

##  **差分ポイント：kernel\_syrk**

###  `syrk.c`（ベース実装）：

```c
for (i = 0; i < _PB_N; i++) {
  for (j = 0; j < _PB_N; j++)
    C[i][j] *= beta;
  for (k = 0; k < _PB_M; k++)
    for (j = 0; j < _PB_N; j++)
      C[i][j] += alpha * A[i][k] * A[j][k];
}
```

* **完全な二重ループ**で `C` を更新。
* 対称行列の特性（`C[i][j] == C[j][i]`）を無視してフルサイズで演算。

---

###  `opt_1.c` / `opt_2.c`（同一内容）【参照: 1006†syrk\_opt\_2.c】

```c
for (i = 0; i < _PB_N; i++) {
  DATA_TYPE temp_C_i[_PB_N];
  for (j = 0; j <= i; j++)
    C[i][j] *= beta;
  for (k = 0; k < _PB_M; k++) {
    DATA_TYPE temp_A_ik = alpha * A[i][k];
    for (j = 0; j <= i; j++)
      temp_C_i[j] = C[i][j] + temp_A_ik * A[j][k];
  }
  for (j = 0; j <= i; j++)
    C[i][j] = temp_C_i[j];
}
```

*  **対称行列Cの下三角部分のみ演算**（`j <= i`）。
*  中間計算 `temp_C_i` に一時保存 → メモリアクセス削減。
*  `alpha * A[i][k]` を `temp_A_ik` に保持し、演算を一回に最適化。
* ただし `temp_C_i[j]` に `+=` ではなく `=` 代入 → 計算の一貫性に注意必要。

---

###  `opt_3.c`：

```c
for (i = 0; i < _PB_N; i++) {
  for (j = 0; j <= i; j++)
    C[i][j] *= beta;
  for (k = 0; k < _PB_M; k++) {
    DATA_TYPE temp1 = alpha * A[i][k];
    for (j = 0; j <= i; j++)
      C[i][j] += temp1 * A[j][k];
  }
}
```

*  `temp1 = alpha * A[i][k]` で定数畳み込み。
*  `temp_C_i` を使わず、**直接 `C[i][j]` に加算**。
*  最小限のループネスト＆演算回数。
*  `opt_1/2` に比べて **メモリ使用を削減**。
*  計算結果の逐次更新により、**よりリアルタイムな更新処理**。

---

##  最適化まとめ：

| 項目      | syrk.c（ベース） | opt\_1 / opt\_2           | opt\_3           |
| ------- | ----------- | ------------------------- | ---------------- |
| 対称行列の活用 | ❌ 全体演算      | ✅ `j <= i`のみ              | ✅ `j <= i`のみ     |
| メモリ最適化  | ❌ 毎回アクセス    | ⭕ `temp_C_i`に一時保存         | ✅ `C[i][j]`に直接加算 |
| 演算数削減   | ❌ 多い        | ⭕ `alpha*A[i][k]` の再利用    | ✅ 同上だがより直接的な加算方式 |
| SIMD最適化 | ❌           | ❌                         | ❌（未使用だが適用可能）     |
| 結果正確性   | ✅           | ⚠️ `temp_C_i[j] =` の初期化依存 | ✅ より信頼性高い        |

---


* **opt\_3.c** が最も効率的なアプローチで、無駄のない計算とメモリアクセスを実現している。
* **opt\_1/2** は `temp_C_i` を使うことでバッファリングしてるが、逐次更新型に劣るケースもある。
* **ベース実装**は最も非効率だが、理解しやすく正確性が高い。


</details>

<details><summary>ll</summary>

---

##  syrk 系列最適化比較

###  ベース (`syrk.c`)

* **アルゴリズム内容**：

  * SYRK (Symmetric Rank-K update) 計算。
  * `C[i][j] = beta * C[i][j] + alpha * A[i][k] * A[j][k]`
* **実装**：

  * 3重ループ（`i`, `j`, `k`）による計算。
  * `C[i][j] *= beta` 処理後、`C[i][j] += alpha * A[i][k] * A[j][k]` を加算。

---

###  `syrk_opt_1.c` の最適化内容

1. **OpenMP並列化**：

   * `#pragma omp parallel for` により最上位ループ（`i`）の並列化。
2. **ループ順序**：変更なし（`i`, `j`, `k`）

 **効果**：複数スレッドを使用してループを分散処理し、CPUマルチコアを活かす最初のステップ。

---

###  `syrk_opt_2.c` の最適化内容

1. **OpenMP並列化**：維持
2. **内部演算の簡略化**：

   * `temp` という変数を導入し、`alpha * A[i][k]` を再利用（計算削減）

```c
temp = alpha * A[i][k];
C[i][j] += temp * A[j][k];
```

 **効果**：乗算を1回に減らし、命令数を削減。メモリアクセスの再利用性向上。

---

###  `syrk_opt_3.c` の最適化内容

1. **OpenMP並列化**：維持
2. **SIMD指示追加**：

   * `#pragma omp simd` により `j` ループに SIMD ベクトル化を指示
3. **ループ内再利用最適化**：`temp` 導入（opt\_2と同様）

 **効果**：

* SIMD（Single Instruction Multiple Data）命令により、ベクトルユニットを用いた高速演算が可能に。
* 複数の `C[i][j]` に対して同時に計算を行える。

---

##  比較まとめ表

| 項目              | ベース | opt\_1     | opt\_2              | opt\_3                 |
| --------------- | --- | ---------- | ------------------- | ---------------------- |
| OpenMP並列化       | ❌   | ✅ (`i`ループ) | ✅                   | ✅                      |
| 再利用変数 `temp` 導入 | ❌   | ❌          | ✅ (`alpha*A[i][k]`) | ✅                      |
| SIMDベクトル化       | ❌   | ❌          | ❌                   | ✅ (`#pragma omp simd`) |
| 演算回数削減          | ❌   | ❌          | ✅                   | ✅                      |

---

##  総評

* **opt\_1**: 並列処理によるスレッド活用。
* **opt\_2**: 乗算の再利用で計算効率UP。
* **opt\_3**: ベクトル化により命令レベル並列性を最大活用。

---
</details>
