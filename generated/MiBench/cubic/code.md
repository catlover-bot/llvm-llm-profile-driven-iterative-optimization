<details><summary>c</summary>

---

## 共通変更ポイント

* **定数の事前計算**

  * `sqrt(Q)` を都度呼び出すのではなく、`double sqrtQ = sqrt(Q);` に格納
  * `a1/3.0` を都度書く代わりに、`double a1_div_3 = a1/3.0;` でキャッシュ
* **数学関数の引数簡略化**

  * もとの `acos(R/sqrt(Q*Q*Q))` を `acos(R/(Q*sqrtQ))` と書き換え
* **`else` 節の `pow` 呼び出し前後の統一**

  * `double absR = fabs(R); double sqrt_R2_Q3 = sqrt(R2_Q3);` を明示的に変数に取り出し

---

## バージョン別差分一覧

| 比較項目              | オリジナル (`cubic.c`)          | 最適化1 (`cubic_1.c`)                                        | 最適化2 (`cubic_2.c`)                                                               | 最適化3 (`cubic_3.c`)                                           |
| :---------------- | :------------------------- | :-------------------------------------------------------- | :------------------------------------------------------------------------------- | :----------------------------------------------------------- |
| **cos 系列の計算**     | 直接３回 `cos(...)` 呼び出し       | `cos(theta/3)`, `cos((θ+2π)/3)`, `cos((θ+4π)/3)` を個別変数に格納 | 同 **＋** `neg2_sqrtQ = -2.0*sqrtQ` を導入し、`long double cos_vals[3] = {…}` に詰めてループ処理 | `neg2_sqrtQ` は同様。`cos_vals[2]` 配列（残余２つ）＋`cos(theta/3)`１変数で展開 |
| **ループ or 展開**     | 展開なし                       | 展開なし                                                      | `for (i=0;i<3;++i)` で３解を一気にセット                                                   | 明示的な `x[0]`, `x[1]`, `x[2]` 書き出し（ループ展開した状態）                  |
| **定義済みマクロの利用**    | 毎回 `sqrt(Q)` や `a1/3.0` 計算 | `sqrtQ`, `a1_div_3` を使う                                   | 同                                                                                | 同                                                            |
| **`else` 節の一時変数** | なし                         | `absR`, `sqrt_R2_Q3` を導入                                  | 同 **＋** `double temp = pow(...);` で合成結果を一時変数に保持                                  | 同                                                            |
| **可読性・保守性**       | インライン多く冗長                  | 若干読みやすく                                                   | ループ化により更に簡潔                                                                      | 配列長削減＋明示割り当てでバランス                                            |

---

### 解説

1. **最適化1**

   * コード内部で繰り返し計算していた `sqrt(Q)` や `a1/3.0` を変数に格納し、一度だけ計算。
   * `acos` の引数も数式を整理し可読性向上。

2. **最適化2**

   * ３つの `cos(…)` 呼び出しをまとめて配列に格納し、`for` ループで同一処理を実行。
   * 係数 `-2.0*sqrtQ` を `neg2_sqrtQ` に取り出し、乗算を減少。

3. **最適化3**

   * ２つの `cos((θ+…)/3)` は配列でまとめ、１番目の `cos(theta/3)` は個別変数で扱うハイブリッド方式。
   * ループを外しつつも重複コードを排除し、配列アクセスによる簡潔性を両立。

いずれもアルゴリズムと I/O（テスト用 `main`）部分は完全に維持しつつ、再計算の回数削減やループの導入でコードをスリム化しています。これにより、命令数の削減やキャッシュ利用効率の向上が期待できます。

</details>

<details><summary>ll</summary>


---

## 1. モジュール情報の更新

|      | ModuleID / source\_filename                                |
| :--- | :--------------------------------------------------------- |
| 元 IR | `ModuleID = 'mibench/automotive/basicmath/cubic.c'`        |
|      | `source_filename = "mibench/automotive/basicmath/cubic.c"` |
| Opt1 | `ModuleID = 'outputs/basicmath/cubic_1.c'`                 |
|      | `source_filename = "outputs/basicmath/cubic_1.c"`          |
| Opt2 | 同様に `cubic_2.c`                                            |
| Opt3 | 同様に `cubic_3.c`                                            |

→ **生成ファイル名** に合わせてメタデータを更新。

---

## 2. 浮動小数点拡張／除算の一本化

```diff
; 元 IR
%11 = fdiv double %3, %0
%12 = fpext double %11 to x86_fp80

; Optimized N
%11 = fdiv x86_fp80 %3, %0
```

* **変化**：`double` → `x86_fp80` への２ステップ（`fdiv`＋`fpext`）を、直接80bit除算 (`fdiv x86_fp80`) に統合。

---

## 3. 冗長定数・再計算の削減

```diff
; 元 IR
%10 = fpext double %9 to x86_fp80
%13 = fmul x86_fp80 %10, 0xKC000C000000000000000

; Optimized 1
%10 = fpext double %9 to x86_fp80
%13 = fmul x86_fp80 %8, %8
```

* **変化**：元は `%10 (= sqrt(R2_Q3))` と定数を乗算していたのを、`%8 (= R)` の自己乗算に置き換え。
* 定数との積を再考し、R²を使った直接演算へ。

---

## 4. FMA（浮動小数点積和）命令の活用

```diff
; 元 IR
%14 = tail call x86_fp80 @llvm.fmuladd.f80(
           x86_fp80 %8, x86_fp80 %8, x86_fp80 %13)

; Optimized N
%14 = tail call x86_fp80 @llvm.fmuladd.f80(
           x86_fp80 %10,    ; sqrt(R2_Q3)
           x86_fp80 CONST,  ; 定数
           x86_fp80 %13     ; R²
)
```

* **変化**：`a*b + c` のパターンを、`fmuladd` 組込命令一本で実行するよう整理。
* レジスタ往復を減らし、パイプライン効率向上。

---

## 5. ループ化／展開の SSA (Static Single Assignment) への反映

* **Optimized 2** では、３つの `cos((θ + k·2π)/3)` をループでまとめていた部分が、SSA上は

  ```llvm
  %angle0 = fdiv ...
  %cos0   = call double @llvm.cos(...)
  %angle1 = fadd %angle0, 2π   ; θ+2π
  %cos1   = call double @llvm.cos(...)
  %angle2 = fadd %angle0, 4π   ; θ+4π
  %cos2   = call double @llvm.cos(...)
  ```

  のように３つのノード列に展開されています。

* **Optimized 3** ではさらに、最初の `cos` を `%cos0`、残りを `%cos1` / `%cos2` と一つずつ個別変数化し、ループの概念を完全に消去。

---

## 6. 定数リテラルの long double 化

* 元 IR では `1/3.0` や `2.0` が `double` として扱われる箇所があったのに対し、最適化版では `1.0L/3.0L`、`2.0L` と `x86_fp80` 型に適合するリテラルに置き換えられ、型変換を減少。

---

## 7. 全体の IR サイズ変化

|     Version | IR Lines | Added | Removed |
| ----------: | -------: | ----: | ------: |
|    Original |      136 |     0 |       0 |
| Optimized 1 |      128 |    10 |      18 |
| Optimized 2 |      124 |     8 |      20 |
| Optimized 3 |      120 |     6 |      22 |

* **行数順に削減**：最適化1→2→3 の順に IRをコンパクト化。
* **命令集の削減**：不要な拡張／定数展開／中間ノードを排除。

---

### 結論

これらの IRレベルの変化は、最終的に生成されるマシンコードの **命令数削減** と **レジスタ利用効率向上** に直結します。FMA活用や冗長演算の統合により、パフォーマンスが高まることが期待されます。


</details>
