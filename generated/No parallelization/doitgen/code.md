<details><summary>c</summary>

以下の4 つのソースコードを、主にカーネル部の「ループ構造」「一時変数の扱い」「ポインタ／配列アクセス」「その他初期化・出力処理の最適化」という観点で比較します。

| ファイル名          |         ループのアンローリング幅         |        一時変数の格納場所       |                             ポインタ／アクセス最適化                            | init／print 側の変更点                                                                |
| :------------- | :--------------------------: | :--------------------: | :-----------------------------------------------------------------: | :------------------------------------------------------------------------------ |
| **doitgen.c**  | アンローリングなし<br>（p ごとに sum\[p]） |    グローバル配列 `sum[NP]`   |                      2D 配列アクセスそのまま (`C4[s][p]`)                     | 標準的な三重ループで初期化・出力                                                                |
| **opt\_1**     |         2 倍（`p += 2`）        |    グローバル配列 `sum[NP]`   |                              アクセスは元のまま                              | init／print はオリジナルと同様                                                            |
| **opt\_2**     |         4 倍（`p += 4`）        | ローカル変数 `temp0`～`temp3` |            アクセスは `C4[s][p+k]` のまま<br>だが sum 配列を廃止しレジスタ利用            | init／print 同様                                                                   |
| **opt\_3**     |         4 倍（`p += 4`）        | ローカル変数 `temp0`～`temp3` | - `C4[s]`→`C4s` のポインタキャッシュ<br>- `A[i][j]` を `Aj` でキャッシュ（init／print） | - init: `Aj = A[i][j]`、`C4i = C4[i]` を用いてポインタ経由で初期化<br>- print: 同様に `Aj` ポインタ使用 |

---

## 各最適化のポイント

1. **baseline（doitgen.c）**

   * 完全三重ループ＋第4 ループで `sum` 配列に書き込み、その後もう一度ループで `A[...] = sum[...]` とする構造。
   * 分かりやすいが、`sum` への書き込み→読み出しがメモリアクセスを増やす 。

2. **opt\_1**

   * p 方向に対して 2 つずつまとめて処理し、内側ループで同時に `sum[p]`／`sum[p+1]` を更新。
   * アンローリングによりループオーバーヘッドを削減するが、依然 `sum` 配列を経由するのでメモリ負荷は残る 。

3. **opt\_2**

   * アンローリング幅を 4 に拡大し、`sum` 配列を廃止。`temp0`～`temp3` にレジスタ内で蓄積し、ループ後すぐに `A[r][q][p+k]` に書き戻す。
   * メモリアクセスの多段階読書きをなくし、レジスタ活用を最大化してスループットを向上 。

4. **opt\_3**

   * **opt\_2** の手法を踏襲しつつ、さらに以下を導入：

     * `C4[s]`→`C4s` のポインタキャッシュにより、`C4[s][p+k]` のアドレッシングコストを軽減。
     * `init_array`／`print_array` 側でも `Aj = A[i][j]`、`C4i = C4[i]` としてポインタ経由でのアクセスに統一し、データ局所性を改善 。
   * 内部ループでの乗算・加算に集中できるため、メモリ帯域の制約が緩和される。

---

### まとめ

* **doitgen.c**：機能的には最もシンプルだが、メモリアクセスとループオーバーヘッドが大きい。
* **opt\_1**：軽微なアンローリング（×2）でオーバーヘッド削減。
* **opt\_2**：アンローリング（×4）＋レジスタ活用でメモリアクセスを大幅削減。
* **opt\_3**：さらにポインタキャッシュを導入し、メモリ／アドレス計算コストを最適化。


</details>

<details><summary>ll</summary>

以下の表は、添付された LLVM IR ファイル（baseline と 3 種類の最適化バージョン）をロード／ストア命令数と GEP（getelementptr）命令数で比較したものです。各値は IR 全体から単純に命令をカウントした結果です。

| バージョン                                 | load 命令数 | store 命令数 | getelementptr 命令数 | IR 上の最適化ポイント                                                  |
| :------------------------------------ | :------: | :-------: | :---------------: | :------------------------------------------------------------ |
| **baseline**<br>`doitgen_opt_base.ll` |    109   |    102    |        199        | ・完全三重ループ<br>・`sum` 配列への逐次的な読み書きが多数                            |
| **opt\_1**<br>`doitgen_opt_1.ll`      |    113   |    105    |        204        | ・p 方向にアンローリング（×2）→ループオーバーヘッド軽減<br>・レジスタ利用はせずメモリアクセスに依存        |
| **opt\_2**<br>`doitgen_opt_2.ll`      |    30    |     7     |         31        | ・アンローリング（×4）＋`temp0`～`temp3` レジスタ蓄積<br>・`sum` 配列除去でメモリアクセス激減  |
| **opt\_3**<br>`doitgen_opt_3.ll`      |    30    |     7     |         40        | ・opt\_2 に加えポインタキャッシュ（`C4s`, `Aj`）を導入<br>・GEP は増えつつもロード／ストアは同等 |

---

## 要点まとめ

1. **メモリアクセスの削減**

   * baseline → opt\_1 はアンローリング×2 でやや増加（展開に伴う命令重複）が見られるものの、オーバーヘッドは低減。
   * opt\_2 ではアンローリング×4 ＋レジスタ（`temp0`～`temp3`）により、load/store がそれぞれ 109→30、102→7 と大幅に激減。

2. **ポインタキャッシュの導入（opt\_3）**

   * opt\_2 の IR に対し、各ループ入口で `C4s = &C4[s][0]` や `Aj = &A[i][j]` を計算するコードを挿入。
   * これにより GEP 命令が opt\_2 の 31 → opt\_3 の 40 に増加するものの、実行ループ中のアドレッシングコストが軽減。

3. **関数アトリビュートの違い**

   * baseline／opt\_1 ではポインタ引数に汎用的なメモリ読み書き属性（`memory(argmem: readwrite)`）が付与される一方、opt\_2／opt\_3 では不要な読み込みがなくなったことを示す `readnone` 属性が `%5`（出力行列）に付与。

---

以上の比較から、IR レベルでは「アンローリング＋レジスタ蓄積」によるメモリアクセス削減が最も効果的であり、さらに「ポインタキャッシュ」を導入することでループ内部のアドレス計算コストを低減できることが示されています。メモリ負荷削減の度合いは

```
doitgen_opt_base.ll < doitgen_opt_1.ll < doitgen_opt_2.ll ≃ doitgen_opt_3.ll  
```

という順序で最適化効果が確認できます。

</details>
