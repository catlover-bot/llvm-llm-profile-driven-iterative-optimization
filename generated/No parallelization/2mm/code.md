<details><summary>c</summary>

以下、PolyBench/C の２乗行列積ベンチマーク 2mm のオリジナル実装（2mm.c）と３つの最適化版（opt1, opt2, opt3）の主な違いをまとめます。

| 項目          | 2mm.c（オリジナル）                                             | opt1（アンローリング×2）                          | opt2（アンローリング×4）                     | opt3（アンローリング×4）                     |
| ----------- | -------------------------------------------------------- | ---------------------------------------- | ----------------------------------- | ----------------------------------- |
| **内側ループ幅**  | `for (k=0; k<_PB_NK; ++k)`                               | `for (k=0; k<_PB_NK; k+=2)`              | `for (k=0; k<_PB_NK; k+=4)`         | `for (k=0; k<_PB_NK; k+=4)`         |
| **アンローリング** | なし                                                       | 2 要素分一括処理＋残余は `if (k+1<…)` でガード          | 4 要素分一括処理＋残余は `if (k+1/2/3<…)` でガード | 4 要素分一括処理＋残余は `if (k+1/2/3<…)` でガード |
| **累積変数**    | `tmp[i][j] += …` へ毎回メモリ書き込み                              | ローカル変数 `sum` に一旦保持、ループ後に `tmp[i][j]=sum` | 同左                                  | 同左                                  |
| **第二フェーズ**  | `D[i][j] *= beta; for(k…) D[i][j] += tmp[i][k]*C[k][j];` | 同じくアンローリング×2                             | 同じくアンローリング×4                        | 同じくアンローリング×4                        |
| **目的**      | リファレンス実装                                                 | アンローリングによるループオーバーヘッド・メモリアクセス低減           | より大きなアンローリングでさらなる性能向上を狙う            | opt2 とコード上は同一（バージョン差分なし）            |

---

### 各バージョンの狙いと効果

1. **2mm.c（オリジナル）**

   * 典型的な三重ループで行列積を実装。
   * 毎回 `tmp[i][j]` や `D[i][j]` に書き戻すため、メモリ帯域とストア命令が多い 。

2. **opt1（アンローリング×2）**

   * 内側ループを 2 つずつ処理 (`k+=2`)。
   * ループ境界での残余要素処理は `if (k+1 < _PB_NK)` でガード。
   * ローカル変数 `sum` に結果を一時保持し、メモリアクセスをループ外へ。これによりレジスタ再利用が促進される 。

3. **opt2（アンローリング×4）**

   * アンローリング幅を 4 に拡大 (`k+=4`)、残余は同様に `if (k+1/2/3 < _PB_NK)` で処理。
   * 読み出し・乗算・加算を 4 回まとめて行うことでループオーバーヘッドをさらに削減。
   * 第二フェーズ（`D` 側）も同じく 4×アンローリング。メモリと分岐の削減効果が大きい 。

4. **opt3（アンローリング×4）**

   * コードを確認したところ opt2 とまったく同じ実装でした（行数・処理内容に差分なし） 。
   * バージョン名は異なるものの、ソースコード上は同一のため、何らかの運用上のミスか、ビルドオプションのみ変更された可能性があります。

---

### まとめ

* **メモリアクセスの局所性向上** と **ループオーバーヘッド削減** が各最適化の狙いです。
* アンローリング幅を拡張するほど、分岐・ループ制御コストが減りレジスタ再利用が増えるため、高い性能向上が期待できます。
* opt1→opt2（4 倍アンローリング）でさらなる改善が見込まれますが、opt2 と opt3 の実装は同一なので、違いを検証するにはコンパイルオプションや実行時計測を併せて確認する必要があります。

</details>

<details><summary>ll</summary>

下表は、生成されたLLVM IR（.ll）における主要な違いをまとめたものです。対応するCソースも併せて示しますので、IRレベルの変化。

| 比較ポイント                | base.ll<br>（オリジナル実装）                    | opt1.ll<br>（アンローリング×2）                                         | opt2.ll<br>（アンローリング×4）                                         | opt3.ll<br>（アンローリング×4）    |
| --------------------- | --------------------------------------- | -------------------------------------------------------------- | -------------------------------------------------------------- | ------------------------- |
| **内側 kループの増分**        | `iadd` による `k = k + 1`                  | `iadd` による `k = k + 2`                                         | `iadd` による `k = k + 4`                                         | `iadd` による `k = k + 4`    |
| **アンローリングの具現化**       | ループ本体には単一の `load`,`fmul`,`fadd`,`store` | 各ループ反復内に2回分の `load`,`fmul`,`fadd` が並列記述<br>残余処理は `icmp`＋分岐でガード | 各ループ反復内に4回分の `load`,`fmul`,`fadd` が並列記述<br>残余処理は `icmp`＋分岐でガード | opt2 と同一のIRパターン（ソース上も同実装） |
| **φノード（インデックス制御）**    | 単純な φ ノード                               | φノードで +2 増分を制御                                                 | φノードで +4 増分を制御                                                 | φノードで +4 増分を制御            |
| **`llvm.loop` メタデータ** | `!llvm.loop !N` が各ループヘッダに付与（アンローリング未指定） | ループヘッダに `llvm.loop.unroll.enable` が追加                          | ループヘッダに `llvm.loop.unroll.count = 4` が追加                       | opt2 と同一のメタデータ            |
| **メモリアクセス回数**         | 各反復で `load`×2 + `store`×1               | 反復あたり `load`×2×2 + `store`×1（メモリ書き戻しはループ外）                     | 反復あたり `load`×2×4 + `store`×1（同上）                               | 同上                        |

---

### 解説

1. **ループインクリメントとφノード**
   base.ll は標準的に `k` を +1 ずつ増やすのに対し、opt1.ll では +2、opt2/opt3.ll では +4 ずつ増やしています。これはIRレベルのφノードにおける増分が変わっていることで実現されており、分岐条件もそれに合わせて `icmp ult i64 %k, %_PB_NK` から `icmp ult i64 %k, %_PB_NK` へ同様の変更が入っています。

2. **アンローリングのパターン**

   * **opt1.ll** では、内側の乗算・加算命令が2回分直列に並んでおり、`if (k+1 < _PB_NK)` 相当の分岐で残余要素を処理します。
   * **opt2/opt3.ll** では同じく4回分の命令列が並んでおり、残余処理は `if (k+1/2/3 < _PB_NK)` の分岐でガードされます。
     これにより、ループ分岐のオーバーヘッドが減り、同じBasicBlock内で複数回の乗算・加算をまとめて実行できるようになります。

3. **`llvm.loop` メタデータ**
   各ループヘッダには `!llvm.loop` メタデータが付与されていますが、opt1/opt2/opt3.ll ではさらにアンローリングを指示する属性（`llvm.loop.unroll.enable` や `llvm.loop.unroll.count`）が追加されており、LLVMの最適化パスがこの指示に従ってアンローリングを行ったことを示しています。

4. **opt2 と opt3 の同一実装**
   実際にIRを比較すると、opt2.ll と opt3.ll はモジュールIDの差異以外は完全に同一でした。ソースレベルでも同じアンローリング幅（4）が適用されているため、ビルドオプションや別名管理上の違いを除けば同一実装とみなせます。

---

以上のように、base.ll→opt1.ll→opt2/opt3.ll と進むにつれて、ループアンローリング幅が 1→2→4 と広がり、その分だけループオーバーヘッドが削減され、フェッチ／ストアの命令がループ外あるいは連続実行されるようにIRが変化しています。これにより、特に大きな行列サイズではメモリ帯域と分岐予測コストの削減による性能向上が見込まれます。

</details>
