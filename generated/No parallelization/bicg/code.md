<details><summary>c</summary>

以下は、`bicg` カーネルの LLVM IR（`.ll`）レベルで見た、オリジナル実装（base.ll）と３つの最適化版（opt1.ll～opt3.ll）の主な違いを定性的にまとめた表です。各項目は、対応する C ソースの実装パターンから IR に反映される典型的な差異を示しています。

| 比較項目                  | base.ll                        | opt1.ll                                     | opt2.ll                             | opt3.ll      |
| --------------------- | ------------------------------ | ------------------------------------------- | ----------------------------------- | ------------ |
| **内側ループ増分**           | `j = j + 1`                    | `j = j + 4`                                 | `j = j + 4`                         | `j = j + 4`  |
| **アンローリング実装**         | 単一の `fmul`＋`fadd`＋`store`      | 4 回分の `fmul`＋`fadd` が直列に並ぶ                  | 同上                                  | 同上           |
| **残余処理の境界チェック**       | なし                             | なし                                          | 各アンローリングステップに `icmp`＋`br` ガード（4 つ）  | 同上（4 つのガード）  |
| **累積変数（レジスタ）**        | 毎反復ごとに `s[j]`／`q[i]` をメモリアクセス  | `q_acc` レジスタに一時保持し、反復終了後にまとめて `q[i]` に書き戻し  | 同上                                  | 同上           |
| **`r[i]` のロード位置**     | 内側ループ内で毎回ロード                   | 外側ループヘッダで一度だけロードし、レジスタ `r_i` へ              | 同上                                  | 同上           |
| **メモリ書き戻し（`store`）**  | 内側で `s[j]`＋`q[i]` の 2 回        | 内側で `s[j]` のみ、外側で `q[i]` のみ（計 2 回）          | 同上                                  | 同上           |
| **ロード命令（`load`）**     | `A[i][j]`,`r[i]`,`p[j]` を毎回ロード | `r[i]` は外側、`A`,`p` は内側でロード                  | 同上                                  | 同上           |
| **`phi` ノード数**        | 3 つ（s-init, q-init, 二重ループ）     | 3 つ（s-init, q-init, 二重ループ）                  | 3 つ                                 | 3 つ          |
| **`llvm.loop` メタデータ** | デフォルトの `!llvm.loop`            | 同上                                          | 同上                                  | 同上           |

---

### 解説

1. **ループのインクリメントとアンローリング**
   base.ll では `j` を 1 増加させる単純ループですが、opt1～opt3.ll ではすべて手動アンローリングに合わせて `j += 4` に変更されています。これに伴い、IR の φノードも増分を 4 にするよう書き換わります 。

2. **乗算・加算命令の並列化**
   opt1.ll 以降は、内側ループ本体に 4 セット分の `fmul`＋`fadd` 命令が直列に並びます。これにより、ループ制御のオーバーヘッドを削減しつつ、一度に複数要素をまとめて処理できるようになります 。

3. **残余要素のガード**

   * **opt1.ll** は「サイズは 4 の倍数前提」として境界チェックを省略しています。
   * **opt2.ll / opt3.ll** では、各アンローリングステップごとに `icmp ult`＋`br` 命令で「j + k < M」をチェックし、残余要素を安全に処理する分岐が IR に挿入されます turn11file1。

4. **累積変数とメモリ書き戻し**
   opt1.ll 以降は、`q_acc` としてレジスタ上に累積した後、外側ループ終了時にまとめて `store` するよう IR が変化します。これにより、内側ループでの `store q[i]` が消え、ストア命令が 1 回に減少します 。

5. **ロード命令のホイスティング**
   opt1.ll 以降は、`r[i]` のロードが内外ループのヘッダに移動し、内側ループではレジスタ `r_i` を用います。IR レベルでも、`load r[i]` が１回だけ存在し、ループ本体ではレジスタ参照になるため、ロード命令回数が削減されます 。

---

このように、手動アンローリング、累積レジスタ利用、残余ガードの有無が IR の命令構造にそのまま反映されており、特に `load`／`store` の回数や `icmp`＋`br` の有無といった点で性能への影響が大きく現れます。

</details>

<details><summary>ll</summary>

以下は、`bicg` カーネルの LLVM IR（`.ll`）におけるオリジナル実装（`base.ll`）と３つの最適化版（`opt1.ll`～`opt3.ll`）の主な構造的違いをまとめたものです。

| 比較項目                  | base.ll               | opt1.ll                                                   | opt2.ll                        | opt3.ll                                   |
| --------------------- | --------------------- | --------------------------------------------------------- | ------------------------------ | ----------------------------------------- |
| **ループインデックス増分**       | `%j = j + 1`          | `%j = j + 4`                                              | `%j = j + 4`                   | `%j = j + 4`                              |
| **アンローリングの具現化**       | 1 要素分の `fmul`＋`fadd`  | 4 回分の `fmul`＋`fadd` を直列化                                  | 同上                             | 同上                                        |
| **余剰要素処理（ガード）**       | ループ条件判断のみ             | なし（サイズは 4 の倍数前提）                                          | 各アンローリングステップに `icmp`＋`br` でガード | 各ステップにガードを挿入＋メタデータでアンローリング指示              |
| **累積変数とストアのタイミング**    | 内側ループごとに `store`      | `q_acc`, `s_acc`（ローカル累積）を利用し、内側ではロード＆演算のみ、外側でまとめて `store` | 同上                             | 同上                                        |
| **ロード命令のホイスティング**     | `load r[i]` を内側ループで毎回 | 外側ループヘッダで一度だけロード                                          | 同上                             | 同上                                        |
| **φノード（ループ制御）**       | シンプル φ ノード            | φ ノードの増分が +4 に書き換え                                        | 同上                             | 同上                                        |
| **`llvm.loop` メタデータ** | デフォルトの `!llvm.loop`   | 追加なし                                                      | 追加なし                           | `!llvm.loop.unroll.enable` などのアンローリング属性付き |

---

### ポイント解説

1. **手動アンローリング**

   * `opt1.ll` 以降はいずれも内側ループを 4 要素ずつ処理するように `j += 4` とし、１ループあたり４回分の乗算・加算命令を直列化しています。この変更は φ ノードの増分や分岐命令にも反映され、ループ分岐オーバーヘッドが大幅に減ります。

2. **残余要素の処理**

   * `opt1.ll` は「行列幅がアンローリング幅の倍数」という前提のもと、余剰チェックを省略しています。
   * `opt2.ll`/`opt3.ll` では、各アンローリングステップごとに `icmp ult`＋`br` 命令を挿入し、残余要素を安全に処理するガードを実装しています。

3. **メモリ操作の削減**

   * オリジナルではループ内で都度行っていた `q[i]`・`s[j]` のストアを、`opt1.ll` 以降はローカル変数（レジスタ） `q_acc`/`s_acc` に一時的に保持し、ループ外（外側ループの終了後）でまとめて書き戻すよう IR が変化しています。

4. **ロードのホイスティング**

   * `r[i]` のロードがオリジナルでは内側ループごとに発生していたのに対し、最適化版では外側ループのヘッダ部分に移動して一度だけロードし、内側ループではレジスタ参照に置き換えられています。

5. **メタデータによるアンローリング指示**

   * `opt3.ll` には、LLVM の最適化パスに「ここはアンローリング済み」ということを明示する `!llvm.loop.unroll.enable` や `!llvm.loop.unroll.count` といったメタデータが付与されており、コンパイラの自動最適化との親和性を高めています。

---

以上の IR レベルでの違いが、実際のコード実行時には「分岐命令の削減」「メモリアクセス数の削減」「レジスタ利用率の向上」として性能に現れます。

</details>
