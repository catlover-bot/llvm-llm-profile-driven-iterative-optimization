<details><summary>c</summary>

以下は、`bicg` カーネルの LLVM IR（`.ll`）レベルで見た、オリジナル実装（base.ll）と３つの最適化版（opt1.ll～opt3.ll）の主な違いを定性的にまとめた表です。各項目は、対応する C ソースの実装パターンから IR に反映される典型的な差異を示しています。

| 比較項目                  | base.ll                        | opt1.ll                                     | opt2.ll                             | opt3.ll      |
| --------------------- | ------------------------------ | ------------------------------------------- | ----------------------------------- | ------------ |
| **内側ループ増分**           | `j = j + 1`                    | `j = j + 4`                                 | `j = j + 4`                         | `j = j + 4`  |
| **アンローリング実装**         | 単一の `fmul`＋`fadd`＋`store`      | 4 回分の `fmul`＋`fadd` が直列に並ぶ                  | 同上                                  | 同上           |
| **残余処理の境界チェック**       | なし                             | なし                                          | 各アンローリングステップに `icmp`＋`br` ガード（4 つ）  | 同上（4 つのガード）  |
| **累積変数（レジスタ）**        | 毎反復ごとに `s[j]`／`q[i]` をメモリアクセス  | `q_acc` レジスタに一時保持し、反復終了後にまとめて `q[i]` に書き戻し  | 同上                                  | 同上           |
| **`r[i]` のロード位置**     | 内側ループ内で毎回ロード                   | 外側ループヘッダで一度だけロードし、レジスタ `r_i` へ              | 同上                                  | 同上           |
| **メモリ書き戻し（`store`）**  | 内側で `s[j]`＋`q[i]` の 2 回        | 内側で `s[j]` のみ、外側で `q[i]` のみ（計 2 回）          | 同上                                  | 同上           |
| **ロード命令（`load`）**     | `A[i][j]`,`r[i]`,`p[j]` を毎回ロード | `r[i]` は外側、`A`,`p` は内側でロード                  | 同上                                  | 同上           |
| **`phi` ノード数**        | 3 つ（s-init, q-init, 二重ループ）     | 3 つ（s-init, q-init, 二重ループ）                  | 3 つ                                 | 3 つ          |
| **`llvm.loop` メタデータ** | デフォルトの `!llvm.loop`            | 同上                                          | 同上                                  | 同上           |

---

### 解説

1. **ループのインクリメントとアンローリング**
   base.ll では `j` を 1 増加させる単純ループですが、opt1～opt3.ll ではすべて手動アンローリングに合わせて `j += 4` に変更されています。これに伴い、IR の φノードも増分を 4 にするよう書き換わります 。

2. **乗算・加算命令の並列化**
   opt1.ll 以降は、内側ループ本体に 4 セット分の `fmul`＋`fadd` 命令が直列に並びます。これにより、ループ制御のオーバーヘッドを削減しつつ、一度に複数要素をまとめて処理できるようになります 。

3. **残余要素のガード**

   * **opt1.ll** は「サイズは 4 の倍数前提」として境界チェックを省略しています。
   * **opt2.ll / opt3.ll** では、各アンローリングステップごとに `icmp ult`＋`br` 命令で「j + k < M」をチェックし、残余要素を安全に処理する分岐が IR に挿入されます turn11file1。

4. **累積変数とメモリ書き戻し**
   opt1.ll 以降は、`q_acc` としてレジスタ上に累積した後、外側ループ終了時にまとめて `store` するよう IR が変化します。これにより、内側ループでの `store q[i]` が消え、ストア命令が 1 回に減少します 。

5. **ロード命令のホイスティング**
   opt1.ll 以降は、`r[i]` のロードが内外ループのヘッダに移動し、内側ループではレジスタ `r_i` を用います。IR レベルでも、`load r[i]` が１回だけ存在し、ループ本体ではレジスタ参照になるため、ロード命令回数が削減されます 。

---

このように、手動アンローリング、累積レジスタ利用、残余ガードの有無が IR の命令構造にそのまま反映されており、特に `load`／`store` の回数や `icmp`＋`br` の有無といった点で性能への影響が大きく現れます。

</details>

<details><summary>ll</summary>


</details>
