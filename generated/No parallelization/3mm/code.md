<details><summary>c</summary>

下表は、3 つの行列積を連続して行うベンチマーク 3mm のオリジナル実装（3mm.c）と、３種類の最適化版（opt1, opt2, opt3）の主な違いをまとめた。

| 比較ポイント            | 3mm.c（オリジナル）           | opt1（単一スカラ×4アンローリング）                 | opt2（4 つのスカラ×4アンローリング）                       | opt3（ガード付き×4アンローリング）                   |
| ----------------- | ---------------------- | ------------------------------------ | -------------------------------------------- | -------------------------------------- |
| **アンローリング幅**      | なし（`k++`）              | 4 つまとめて(`k+=4`)                      | 4 つまとめて(`k+=4`)                              | 4 つまとめて(`k+=4`)                        |
| **累積変数（第１フェーズ）**  | `E[i][j]` に都度加算・書き戻し   | ローカル変数 `sum` に一括加算、最後に `E[i][j]=sum` | ローカル変数 `sum0`～`sum3` に並列加算、最後に合算して `E[i][j]` | ローカル変数 `sum0` に一括加算、最後に `E[i][j]=sum0` |
| **残余要素処理**        | ループ外で `k < _PB_NK` のみ  | なし（暗黙にサイズが 4 の倍数前提）                  | なし（同上）                                       | `if(k+1<...){…}` などで残余をガード             |
| **第２フェーズ／第３フェーズ** | 各々も同様に `k++`→`+=`→書き戻し | 各々で `k+=4` & 単一 `sum`                | 各々で `k+=4` & 4 つの `sum`                      | 各々で `k+=4` & ガード付き単一 `sum0`            |
| **データ依存性の緩和**     | ループキャリーのみ              | 単一依存                                 | 4-way 並列依存を分散                                | 単一依存だが条件分岐を挟むことで残余処理を安全化               |
| **狙いと効果**         | 最も素直な定義                | ループオーバーヘッド削減＋メモリ書き戻しの回数削減            | データ依存解消によりパイプライン効率化＋同上                       | 範囲外アクセス回避を保証しつつ、アンローリングで分岐を削減          |

---

### 各実装の特徴とパフォーマンスへの影響

1. **オリジナル実装（3mm.c）**

   * 三重ループをそれぞれ `k++` で進め、都度配列に書き戻し 。
   * ループ制御コストとメモリストアが多く、パフォーマンスのボトルネックになりやすい。

2. **opt1**

   * ループを 4 要素ずつ処理 (`k+=4`)。
   * 単一のローカル変数 `sum` に加算した後、一度だけ配列に書き戻す。
   * ループ分岐とストア命令を大幅に削減し、メモリ帯域と分岐予測コストを低減 。

3. **opt2**

   * さらに一歩進め、`sum0`～`sum3` の４つのローカル変数を用意し、依存を分散。
   * パイプラインのスループットを高め、アンローリングの効果を最大化することで、より高い IPC（Instructions Per Cycle）を狙う 。

4. **opt3**

   * opt1 と同様の単一累積変数を使いつつ、アンローリング内で `if (k+1<...)` などにより残余要素を安全に処理。
   * データサイズがアンローリング幅の倍数でない場合にも正しく動作し、汎用性を確保しつつループオーバーヘッドを削減 。

---

**まとめ**

* **ループアンローリング** により分岐とストアを減らすのが共通の狙い。
* **複数累積変数**（opt2）は依存チェーンを分散し、CPU のパイプライン効率を高める。
* **残余処理ガード**（opt3）は安全性を担保しつつ、最適化効果を維持。
* 実際の性能向上には配列サイズ（NI,NJ,NK…）やキャッシュサイズ、コンパイラ設定との兼ね合いも重要です。

</details>

<details><summary>ll</summary>

以下の観点で `base.ll` と各最適化版（`opt1.ll`，`opt2.ll`，`opt3.ll`）のLLVM IRを比較できます。

| 比較項目                  | base.ll                         | opt1.ll                                   | opt2.ll                                         | opt3.ll                                           |
| :-------------------- | :------------------------------ | :---------------------------------------- | :---------------------------------------------- | :------------------------------------------------ |
| **ループインデックスの増分**      | `k` を `+1` ずつ (`add i32 %k, 1`) | `k` を `+4` ずつ (`add i32 %k, 4`)           | 同じく `+4` ずつ                                     | 同じく `+4` ずつ                                       |
| **乗算＋加算命令の繰り返し数**     | 1回だけ                            | 4回分を逐次的に並べる（`sum += A*B; sum += A*B; …`）  | 4つの局所変数 (`sum0`～`sum3`) を用意し、それぞれで積を累積 → 最後に合計  | opt2 と同様の4変数アンローリング＋ループ内での余剰ガード挿入                 |
| **余剰要素処理（境界テスト）**     | なし（ループ終了条件で完結）                  | ループ内で `if (k+1 < N) …` といったガード命令をインライン化   | ガードはループ外でまとめる場合あり                               | ループ内にインライン化（opt1 同様）                              |
| **`llvm.loop` メタデータ** | アンローリング指定なし                     | 手動アンローリングなのでメタデータは特になし                    | 同じく特になし                                         | `!llvm.loop.unroll.enable` やアンローリング保証のメタデータが付加される |

---

### 詳細解説

1. **ループインデックスの増分**

   * **base.ll** では

     ```llvm
     %k.next = add i32 %k, 1
     br label %loop
     ```

     のように1ずつ進みます。
   * **opt1～opt3.ll** ではすべて

     ```llvm
     %k.next = add i32 %k, 4
     br label %loop.unrolled
     ```

     とし，マニュアルアンローリング幅に合わせて `k+=4` に変更されています。

2. **命令列の繰り返し**

   * **base.ll**：1周あたりロード→`fmul`→`fadd`→ストアが1セット。
   * **opt1.ll**：同一ブロック内に同じロード／演算を4回並べた直列化版。
   * **opt2.ll**：`sum0`～`sum3` の4局所変数を用意し，4要素分を並列に累積 → 最後に `fadd` で合成。
   * **opt3.ll**：opt2 の構造＋ループ内での余剰ガード（`if (k+1 < N) …`）をインライン化。

3. **余剰要素処理**

   * **opt1**，**opt3**：ループ本体に `icmp ult k+1, N` → `br` で `sum += …` を分岐する，いわゆるガード付きアンローリング 。
   * **opt2**：余剰部分のガードはメインループ外か，または残余用の別ループでまとめる実装が多いです。

4. **メタデータ**

   * **opt3.ll** には

     ```llvm
     !0 = distinct !{!0, !llvm.loop.unroll.enable}
     br label %loop, !llvm.loop !0
     ```

     といったアンローリング有効化のマーカーが付き，コンパイラにもアンローリングを強く指示します。

---

このように，`base.ll` は素直な１要素ずつのループですが，`opt1`～`opt3` はそれぞれマニュアルアンローリング幅の違いや，累積変数の分割、ガードの配置、メタデータの付与といったIRレベルの構造差異があります。

</details>
