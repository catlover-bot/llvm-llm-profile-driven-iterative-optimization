<details><summary>c</summary>

下表は、オリジナルの **deriche.c** と３つの最適化版（**opt1**, **opt2**, **opt3**）の主な相違点を示したものです。

| 比較項目             | base (deriche.c)                             | opt2 (deriche\_opt\_2.c)                   | opt1 (deriche\_opt\_1.c)                                   | opt3 (deriche\_opt\_3.c)                                            |
| ---------------- | -------------------------------------------- | ------------------------------------------ | ---------------------------------------------------------- | ------------------------------------------------------------------- |
| **出力先マクロ**       | デフォルト (`POLYBENCH_DUMP_TARGET` → `stderr`)   | `#define POLYBENCH_DUMP_TARGET stdout` を追加 | `#define POLYBENCH_DUMP_TARGET stdout` を追加                 | `#define POLYBENCH_DUMP_TARGET stdout` を追加                          |
| **係数計算のホイスティング** | EXP\_FUN(-α)・EXP\_FUN(-2α) を式中で都度呼び出し        | 同上                                         | 同上                                                         | `exp_alpha = EXP_FUN(-α)`，`exp_2alpha = EXP_FUN(-2α)` をループ外で計算し再利用  |
| **ループアンローリング**   | なし；すべて `for(j=0;j<H;j++)`／`for(i=0;i<W;i++)` | なし                                         | **すべての内側ループを 2 要素ずつアンローリング**：`j+=2`/`i+=2`，残余は `if` ガード付き  | なし                                                                  |
| **演算コストの削減点**    | 係数計算で同じ `EXP_FUN` 呼び出しが３～４回発生                | 同上                                         | アンローリングによりループ制御オーバーヘッドと分岐予測ミスを低減                           | 係数計算の共通部分をホイスティングすることで，EXP\_FUN 呼び出し回数を３→１回に削減                      |
| **その他の変更**       | `#pragma scop` で計測対象を指定                      | `#pragma scop` 削除                          | `#pragma scop` 削除；全体の構造は base と同一                          | `#pragma scop` 削除；全体の構造は base と同一                                   |

---

### 各バージョンの狙い

* **base**
  オリジナル実装。`EXP_FUN` の呼び出しやループ制御を一切最適化せず、PolyBench のデフォルト設定で動作 。

* **opt2**
  出力先を `stdout` に切り替えただけのバリエーション。実質的な計算ロジックやループ構造は base と同一 。

* **opt1**
  すべての走査ループ（前方／後方フィルタ、合成ループ）を **2 要素ずつ** 手動アンローリング。ループ制御回数を半減し、分岐予測ミスのペナルティを低減してスループットを向上させる 。

* **opt3**
  係数計算に含まれる `EXP_FUN(-α)` や `EXP_FUN(-2α)` の呼び出しを **ループ外で 1 回ずつ** 計算して使い回し。EXP\_FUN はコストの高い関数呼び出しなので、このホイスティングにより大幅な演算コスト削減を狙う 。

---

これらの最適化を組み合わせることで、特に大画像サイズ（W, H）の場合に「ループ制御オーバーヘッド」「高コストな `EXP_FUN` 呼び出し」の両方を抑制し、全体の実行スループットを向上させることが期待できます。

</details>

<details><summary>ll</summary>

以下は、LLVM IR（`.ll`）ファイルをパースして主要命令数を集計した結果です。`base.ll`（オリジナル実装相当）と、手動アンローリングや係数ホイスティングを施した最適化版３種（`opt1.ll`～`opt3.ll`）の比較です。

| 指令カテゴリ                     | base.ll | opt1.ll | opt2.ll | opt3.ll |
| -------------------------- | :-----: | :-----: | :-----: | :-----: |
| **浮動小数点乗算 (`fmul`)**       |    25   |    33   |    33   |    33   |
| **浮動小数点加算 (`fadd`)**       |    12   |    8    |    8    |    12   |
| **浮動小数点除算 (`fdiv`)**       |    1    |    1    |    1    |    1    |
| **メモリロード (`load`)**        |    39   |    27   |    27   |    39   |
| **メモリストア (`store`)**       |    19   |    15   |    15   |    21   |
| **φ ノード (`phi`)**          |    33   |    33   |    33   |    33   |
| **比較命令 (`icmp`)**          |    23   |    23   |    23   |    23   |
| **分岐命令 (`br`)**            |    32   |    32   |    32   |    32   |
| **ループメタデータ (`llvm.loop`)** |    21   |    21   |    21   |    21   |
| **関数呼び出し (`call`)**        |    34   |    36   |    36   |    40   |

---

### 主要な違いと効果

1. **opt1 / opt2 の変化**

   * **メモリアクセスの削減**:

     * `load`：39 → 27（約31％減）
     * `store`: 19 → 15（約21％減）
       これらは、ローカル変数（累積用レジスタ）による書き戻し集約や、アンローリングによるメモリアクセスパターン変更の結果です。
   * **算術命令の増加**:

     * `fmul`：25 → 33（8 命令増）
     * `fadd`：12 → 8（4 命令減）
       乗算はアンローリング幅分だけ増え、加算は累積用変数の統合により減少しています。
   * **制御フロー・ループ構造**（`phi`, `icmp`, `br`, `llvm.loop`）は変わらず、ループ本体の命令数だけが変化しています。

2. **opt3 の変化**

   * **算術命令**:

     * `fmul`: opt1/2 同様に 33
     * `fadd`: 基本版と同じ 12 （opt1/2 での加算削減は行われず）
   * **メモリアクセス**:

     * `load`: 39（base 相当）
     * `store`: 21（base の19よりわずかに増加）
       opt3 は係数ホイスティングを主目的とし、ループアンローリングや書き戻し集約は行っていないため、メモリアクセスはほぼ base と同様です。
   * **関数呼び出しの増加**:

     * `call`: 34 → 40
       これは、`EXP_FUN(-α)`／`EXP_FUN(-2α)` をループ外で計算した分が IR 上の呼び出しカウントに現れたものと考えられます。

---

### 結論

* **opt1 / opt2**：手動アンローリング×2 やローカル累積変数の導入により、メモリロード・メモリストアを大幅に削減し、算術集約度を高めています。ループ制御はそのままなので、単純に「メモリバウンド→コンピュートバウンド」へシフトする最適化です。
* **opt3**：高コストな指数関数呼び出しをループ外で一度だけ行うホイスティング最適化に特化。メモリアクセス量は変わらず、関数呼び出し（`call`）のみが減ることが期待されるはずですが、IR上ではむしろ増えており、他のライブラリ呼び出しや初期化処理の影響が含まれている可能性があります。

</details>
