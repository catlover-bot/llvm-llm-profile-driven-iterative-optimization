<details><summary>c</summary>

以下に、オリジナル実装（`adi.c`）と３つの最適化版（`opt1`～`opt3`）の主な違いをまとめます。

| 比較項目                | base (`adi.c`)                                                               | opt1 (`adi_opt_1.c`)                             | opt2 (`adi_opt_2.c`)                                                 | opt3 (`adi_opt_3.c`)                                       |
| ------------------- | ---------------------------------------------------------------------------- | ------------------------------------------------ | -------------------------------------------------------------------- | ---------------------------------------------------------- |
| **前処理（定数計算）**       | ループ開始直前に `DX, DY, DT, B1, B2, mul1, mul2, a, b, c, d, e, f` を計算。             | 同左                                               | 同左                                                                   | `inv_b = 1/b`，`inv_e = 1/e` を追加で計算（ループ外で一度だけ）              |
| **累積変数の導入**         | `p[i][j-1]`／`q[i][j-1]` を都度メモリ読み出し                                           | ローカル変数 `pi_prev, qi_prev` を使い，前回の `p/q` をレジスタに保持 | 同左                                                                   | 同左                                                         |
| **`denom`（分母）の扱い**  | `a * p[i][j-1] + b` を式中で都度計算                                                 | ループ内で `DATA_TYPE denom = a*pi_prev + b;` を一度だけ計算 | 同左                                                                   | 同左                                                         |
| **`p`／`q` への書き戻し**  | `p[i][j] = …; q[i][j] = …;` をそれぞれ別命令で実行                                      | 同左                                               | `pi_prev = p[i][j] = -c/denom; qi_prev = q[i][j] = …/denom;` とインライン化 | 同左                                                         |
| **除算の回数**           | `-c/(…)` と `…/denom` の 2 回除算                                                 | 同左                                               | 同左                                                                   | `pi_prev = -c * inv_b;`（乗算化）＋`…/denom` の 1 回除算＝除算回数を 1 回削減 |
| **後方スイープ（`v`→`u`）** | `for(j=_PB_N-2; j>=1; j--) v[j][i] = p[i][j]*v[j+1][i] + q[i][j];`／同様に `u` 側 | 同左                                               | 同左                                                                   | 同左                                                         |
| **効果の狙い**           | 典型的な二方向三重ループ。メモリ読み書きと除算がボトルネック                                               | `p/q` のメモリアクセスをレジスタに置き換え，メモリ負荷を削減                | `p/q` の更新をインライン化し，命令数・レジスタ再利用を向上                                     | 除算を乗算に置き換え，分母定数化により除算コストをさらに削減                             |

---

### 解説

1. **ローカル変数によるメモリ負荷軽減**

   * base 版では `p[i][j-1]`／`q[i][j-1]` を都度配列から読み出すため，メモリアクセスが多い 。
   * opt1～opt3 では，前回ループの結果を `pi_prev, qi_prev` に保持し，読み出しはループ初回の１回だけに削減 turn9file2turn9file1。

2. **除算コストの削減**

   * opt3 では，`pi_prev = -c / denom` の除算を，ループ外で計算した `inv_b = 1/b` を用いて `pi_prev = -c * inv_b` と乗算に置き換え，１ループあたりの除算回数を１回削減している 。

3. **インライン化による命令数削減**

   * opt2/opt3 は `pi_prev = p[i][j] = -c/denom; qi_prev = q[i][j] = …/denom;` と二重代入を一文にまとめ，命令数とレジスタの利用効率を高めている 。

4. **総合的な性能向上**

   * メモリアクセス削減＋除算回数削減＋命令数最適化により，特に大規模マトリクスや高反復回数の設定では，opt3 が最も大きな速度改善を期待できます。一方で，opt1/opt2 もベースに比べてメモリボトルネックを緩和し，CPU パイプラインのスループットを向上させます。



</details>

<details><summary>ll</summary>

以下、LLVM IR（.ll）レベルで見た `adi` カーネルのオリジナル実装（base）と３つの最適化版（opt1～opt3）の主な違いをまとめます。カウントはそれぞれの .ll ファイル内に定義される命令の行数です。

| 比較項目                  | base.ll                       | opt1.ll | opt2.ll | opt3.ll                                      |
| --------------------- | ----------------------------- | ------- | ------- | -------------------------------------------- |
| **fdiv 命令定義数**        | 10                            | 6       | 6       | 6                                            |
| **fmul 命令定義数**        | 4                             | 2       | 2       | 4                                            |
| **load 命令定義数**        | 39                            | 27      | 27      | 29                                           |
| **store 命令定義数**       | 22                            | 18      | 18      | 18                                           |
| **ループインクリメント**        | `%j.next = add i32 %j, 1`（単一） | 同上      | 同上      | 同上                                           |
| **`denom` 計算位置**      | ループ本体内<br>`fmul`＋`fadd`       | 同上      | 同上      | 同上                                           |
| **除算→乗算への変換**         | ―                             | ―       | ―       | `-c/denom` → `fmul inv_b`（乗算化）               |
| **前計算ブロック（エントリ）での処理** | なし                            | なし      | なし      | `inv_b = 1/b`,<br>`inv_e = 1/e` をエントリで１回だけ計算 |
| **PHI ノード数（ループ制御）**   | 同数                            | 同数      | 同数      | 同数                                           |

---

### 解説

* **除算命令の削減**

  * `fdiv` 命令が定義される行数は、base 版では 10 行ですが、opt1/opt2/opt3 ではそれぞれ 6 行と大幅に削減されています。
  * opt3 ではさらに `pi_prev = -c/denom` の部分をループ外で計算した逆数乗算（`inv_b`）へ置き換えたことで、１つの除算を乗算に変換しています。

* **乗算命令の増減**

  * fmul（浮動小数点乗算）の定義は opt1/opt2 で 2 行に減っていますが、opt3 では逆数乗算導入のために再び 4 行に増えています。

* **メモリアクセスの局所化**

  * load/store 命令の定義行数が、base → opt1/opt2 でそれぞれ 39→27／22→18 と減少。opt3 は前計算値（`inv_b`／`inv_e`）のロードが加わり若干増えています（29）。
  * これは `p[i][j-1]`／`q[i][j-1]` の値をローカル変数（レジスタ）に保持することで、ループごとの配列アクセスを削減したためです。

* **ループ制御まわり**

  * すべてのバージョンで `j` のインクリメントは `add i32 %j, 1` の単一ステップで変わりありません。ループアンローリングは行っていません。
  * PHI ノードによるループ制御の構造も全バージョン共通です。

---


</details>
