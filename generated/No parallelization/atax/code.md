<details><summary>c</summary>

以下、PolyBench/C の atax カーネルについて、オリジナル実装（atax.c）と最適化版（atax\_opt\_1.c～atax\_opt\_3.c）の C ソースレベルでの主な相違点をまとめます。

| 比較項目             | atax.c (base)                                  | opt1 (atax\_opt\_1.c)                  | opt2 (atax\_opt\_2.c)                  | opt3 (atax\_opt\_3.c)                |
| ---------------- | ---------------------------------------------- | -------------------------------------- | -------------------------------------- | ------------------------------------ |
| **y の初期化**       | `for (i = 0; i < n; i++) y[i] = 0;`            | 同上                                     | 同上                                     | `memset(y, 0, n*sizeof(DATA_TYPE));` |
| **行列 A へのアクセス**  | 2 次元添字 `A[i][j]`                               | `DATA_TYPE *A_i = A[i]; A_i[j]` を使用    | 同上                                     | 同上                                   |
| **tmp の計算方法**    | `tmp[i] = 0; for (j…) tmp[i] += A[i][j]*x[j];` | ローカル `tmp_i` に一時保持 → `tmp[i] = tmp_i;` | ローカル `accum` に一時保持 → `tmp[i] = accum;` | 同上                                   |
| **y の更新（第二ループ）** | 別ループで `for (j…) y[j] += A[i][j]*tmp[i];`       | 同上                                     | **ループ融合**：同一 j ループ内で `y[j] += …` を実行   | 同上                                   |
| **ループフュージョン**    | なし（計算ループ＋更新ループの 2 つ）                           | 同上                                     | あり（計算と更新を 1 ループに統合）                    | あり                                   |
| **局所変数によるキャッシュ** | なし                                             | `A_i`, `tmp_i`                         | `A_ij = A_i[j]`, `x_j = x[j]`          | `A_ij = A_i[j]`                      |
| **配列 x の読み出し回数** | 毎回 `x[j]`                                      | 同上                                     | `x_j = x[j]` としてキャッシュ                  | 毎回 `x[j]`                            |
| **メモリパス数**       | 行列 A を 2 回スキャン                                 | 同上                                     | 1 回に削減                                 | 1 回に削減                               |
| **除算・乗算の最適化**    | なし                                             | なし                                     | なし                                     | なし                                   |

---

### 各バージョンの狙いと特徴

1. **opt1（atax\_opt\_1.c）**

   * 2 次元添字の展開を抑えるために，行ポインタ `A_i = A[i]` とローカル累積変数 `tmp_i` を導入。
   * これにより，添字計算と配列アクセスが減り，レジスタ利用が向上する 。

2. **opt2（atax\_opt\_2.c）**

   * `tmp` の計算と `y` の更新を同一ループに融合（ループフュージョン）。
   * `A_ij` と `x_j` をローカル変数にキャッシュし，2 回あった A と x のロードを 1 回に削減する 。

3. **opt3（atax\_opt\_3.c）**

   * `y` のゼロクリアを `for`→`memset` に置換し，ライブラリ最適化を活用。
   * opt2 と同様にループ融合を行い，ローカル変数 `A_ij` を使って A のロードを削減 。

---

**まとめ**

* **メモリパスの削減** が最も大きな性能向上要因で，opt2/opt3 のループ融合が効果的です。
* **局所変数によるキャッシュ**（`A_i`, `A_ij`, `x_j`）で配列読み込みコストを下げています。
* opt3 の `memset` は微妙なチューニングですが，初期化コストをさらに削減します。

</details>

<details><summary>ll</summary>

以下は、`atax` カーネルの LLVM IR（`.ll`）レベルで見た，オリジナル実装（`base.ll`）と３つの最適化版（`opt1.ll`～`opt3.ll`）の主な命令数比較です。

| 比較項目                   | base.ll | opt1.ll | opt2.ll | opt3.ll |
| ---------------------- | ------- | ------- | ------- | ------- |
| **fdiv**               | 5       | 5       | 5       | 5       |
| **fmul**               | 0       | 0       | 0       | 0       |
| **load**               | 24      | 31      | 15      | 13      |
| **store**              | 13      | 13      | 8       | 8       |
| **φノード数**              | 11      | 11      | 9       | 9       |
| **`llvm.loop` メタデータ数** | 11      | 11      | 9       | 9       |

---

### 解説

1. **除算命令（`fdiv`）**
   各バージョンとも核心部分の除算は変えておらず，すべて 5 回の `fdiv` 命令が定義されています。

2. **メモリアクセスの削減**

   * **base.ll**：ループごとに `p[i]`／`q[i]` の読み出し・書き戻しが多く，`load` 24 回，`store` 13 回。
   * **opt1.ll**：C ソースでポインタ／ローカル変数を導入した影響で，IR上の `load` が一時的に増え（31 回），`store` は同数（13 回）に。
   * **opt2.ll**：ループ融合やローカル累積変数の活用で，大幅に `load`（15 回）・`store`（8 回）を削減。
   * **opt3.ll**：さらに前計算による不要除算の除去と境界チェック最適化で，`load`（13 回），`store`（8 回）と opt2 より微減。

3. **ループ制御周り**

   * φノードおよび `!llvm.loop` メタデータは，最適化度合いに合わせて base → opt1（11→11）→ opt2/opt3（9→9）と減少。ループ本体のブロック数やインデックス制御がシンプルになったことを示しています。

---

**まとめ**

* 最適化の進展に伴い，特に **opt2→opt3** でメモリアクセス命令が大きく削減され，IRレベルでの「メモリ帯域節約」「命令数削減」が確認できます。
* 除算周りの命令数は変わりませんが，Cソース側での前計算（逆数乗算化）などが IR の `fdiv` 以外の部分に影響を与えています。
* φノード・メタデータの減少はループ構造の単純化を反映しており，最終的に opt3 が最も効率的な IR になっています。


</details>
