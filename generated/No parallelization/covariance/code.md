<details><summary>c</summary>

下表は、オリジナルの **covariance.c**（base）と最適化版 **opt1**～**opt3** の主な相違点をまとめたものです。

| 比較項目                  | base (`covariance.c`)                     | opt1 (`…_opt_1.c`)                                        | opt2 (`…_opt_2.c`)                                                          | opt3 (`…_opt_3.c`)                                             |
| --------------------- | ----------------------------------------- | --------------------------------------------------------- | --------------------------------------------------------------------------- | -------------------------------------------------------------- |
| **出力マクロ**             | デフォルト（`POLYBENCH_DUMP_TARGET` は `stderr`） | `#define POLYBENCH_DUMP_TARGET stdout` を追加して `stdout` へ出力 | 同上                                                                          | 同上                                                             |
| **初期化（init\_array）**  | `data[i][j] = (i*j)/M;`                   | 同左                                                        | 同左                                                                          | **除算を外に出す**：`temp = i/M; data[i][j] = temp*j;` としてループ内の除算回数を削減 |
| **平均の計算**             | `mean[j]  = ∑₀ⁿ⁻¹ data[i][j] / float_n;`  | **局所変数 `sum`** を使ってから `mean[j] = sum/float_n;`（メモリアクセス低減） | 同上                                                                          | 同上                                                             |
| **平均差し引き (subtract)** | 別ループで `for i,j: data[i][j] -= mean[j]`    | 同左                                                        | **ループ融合**：`for i` の内側で `j<n` の subtract と `j<m` の covariance を連続実行（データ再利用↑） | 同上                                                             |
| **共分散行列計算**           |                                           |                                                           |                                                                             |                                                                |

````c
cov[i][j] = 0;
for(k) cov[i][j] += data[k][i]*data[k][j];
cov[i][j] /= (float_n-1);
cov[j][i] = cov[i][j];
``` | **局所変数 `sum`** に accumulate → `cov[i][j] = sum/(…); cov[j][i]=…;`（内側ループの `store` 回数低減）                                                                    | 同左                                                                                                                                                                          | **手動アンローリング×2**：  
```c
sum1 += …;  
if(k+1<…) sum2 += …;  
…  
sum=(sum1+sum2)/(…);  
cov[i][j]=cov[j][i]=sum;
````

で `k += 2` ずつ処理、分岐ガードあり（ループ制御オーバーヘッド半減）          |
\| **累積変数**               | 直接 `cov[i][j]`                                             | `sum`（ローカル）                                                                                                                                                                   | 同左                                                                                                                                                                          | `sum1`,`sum2`（２つのローカル変数）                                                                                                                                          |
\| **ループオーバーヘッド**   | k を `+1` ずつ                                                | 同左                                                                                                                                                                             | 同左                                                                                                                                                                          | k を `+2` ずつ、各ステップで `if(k+1<…)` ガード（ブランチ数↑だが分岐予測しやすい、小さいオーバーヘッド）                                                    |

---

**まとめ**

* **opt1**：局所変数を導入してメモリアクセス／ストア回数を減らし、出力先を `stdout` に固定 。
* **opt2**：mean 差し引きと covariance 計算を同一ループに融合し、データ再利用性を向上 。
* **opt3**：さらに k ループを手動で 2 要素ずつアンローリングし、分岐ガード付きでループオーバーヘッドを半減 。
* **opt3** の init\_array では行列初期化における除算をループ外へホイストし、細かな算術コストも削減しています。

これらの改良により、特に大規模データを扱う際の「メモリ帯域節約」「ループ制御コスト削減」「キャッシュ局所性向上」が期待できます。
</details>

<details><summary>ll</summary>

以下は、LLVM IR（`.ll`）ファイルの主要命令数を集計した結果です。`covariance_opt_base.ll`（base）と最適化版３種類（opt1～opt3）を比較しています。

| ファイル     | fmul | fadd | fdiv | load | store | φノード | icmp |  br | !llvm.loop |
| -------- | :--: | :--: | :--: | :--: | :---: | :--: | :--: | :-: | :--------: |
| **base** |   3  |   4  |   5  |  29  |   21  |  15  |  15  |  23 |     12     |
| **opt1** |   3  |   5  |   5  |  30  |   13  |  15  |  15  |  23 |     12     |
| **opt2** |   3  |   5  |   5  |  21  |   9   |  13  |  11  |  19 |     10     |
| **opt3** |   4  |   6  |   3  |  20  |   9   |  13  |  11  |  19 |     10     |

* **opt1**（局所変数 `sum` の導入）

  * `store` 命令が 21→13 回と大幅減少。ループ内の書き戻しをまとめて行うことでメモリ帯域を節約。
  * `fadd` が＋1（累積用の加算命令）、`load` は若干増加。
  * ループ制御（φノード、icmp、br）や除算命令（fdiv）は base と同数に留まる。

* **opt2**（ループ融合＋不要メモリ操作削減）

  * `load` が 21 回、`store` は 9 回とさらに削減。
  * φノード・分岐命令（icmp/br）もそれぞれ 2 回分ほど減少。
  * アルゴリズム的に「平均差し引き」と「共分散計算」を同一ループにまとめた結果、IR でもループ回数と制御命令が減っている。

* **opt3**（手動アンローリング×2＋累積変数分散）

  * `fmul` が 3→4 回、`fadd` が 5→6 回に増加（アンローリング分）。
  * `fdiv` が 5→3 回に減少（分母 `(float_n-1)` の除算をループ外／まとめて実行）。
  * `load`/`store` は opt2 と同じ数、φノード・分岐命令も変化なし。`!llvm.loop` メタデータ数も opt2 と一致。

---

**まとめ**

1. **opt1** は「累積変数によるメモリ書き戻し集約」でストア命令を大幅に削減。
2. **opt2** は「ループ融合」でさらにロード・ストア、ループ制御命令を削減。
3. **opt3** は「手動アンローリング×2」によって乗算・加算命令は増やしつつ、除算回数をまとめることで `fdiv` を減少。

これらの IR レベルの差分が、実行時の「メモリ帯域」「ループ分岐コスト」「浮動小数点演算コスト」それぞれに影響し、特に大規模データセットでは顕著な性能改善をもたらします。

</details>
